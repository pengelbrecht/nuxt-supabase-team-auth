{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Nuxt 3 Module Structure and Package Configuration",
        "description": "Set up the foundational Nuxt 3 module structure with proper TypeScript configuration, package.json setup, and CLI tooling for distribution",
        "details": "Create module structure following Nuxt 3 module guidelines:\n- Initialize package.json with @yourco/team-auth name\n- Set up module.ts with defineNuxtModule\n- Configure TypeScript with proper types for Nuxt 3\n- Create CLI entry point for team-auth init/migrate commands\n- Set up build configuration for both module and CLI distribution\n- Configure exports for ESM/CJS compatibility\n- Add peer dependencies: nuxt ^3.0.0, @supabase/supabase-js, @nuxt/ui",
        "testStrategy": "Unit tests for module registration, CLI command parsing, and package structure validation. Integration test for module loading in Nuxt 3 app.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize package.json with proper configuration",
            "description": "Create and configure the package.json file with appropriate metadata, dependencies, and scripts for the Nuxt 3 module.",
            "dependencies": [],
            "details": "Create package.json with name '@yourco/team-auth', set version to '0.1.0', add description, set type to 'module', configure main/module/types fields, add peer dependencies (nuxt ^3.0.0, @supabase/supabase-js, @nuxt/ui), set up dev dependencies (typescript, nuxt, unbuild, etc.), and create basic npm scripts for development, build, and publishing.",
            "status": "done",
            "testStrategy": "Verify package.json structure using npm's package validation and ensure all required fields are present."
          },
          {
            "id": 2,
            "title": "Set up TypeScript configuration",
            "description": "Configure TypeScript for the Nuxt 3 module with proper type definitions and compiler options.",
            "dependencies": [
              1
            ],
            "details": "Create tsconfig.json with appropriate compiler options (target: ESNext, module: ESNext, moduleResolution: bundler, etc.), include necessary type definitions for Nuxt 3, set up paths for module resolution, configure strict type checking, and ensure proper declaration file generation for the module's public API.",
            "status": "done",
            "testStrategy": "Run TypeScript compiler in check mode to verify configuration is valid and types are properly resolved."
          },
          {
            "id": 3,
            "title": "Create module.ts with defineNuxtModule implementation",
            "description": "Implement the core module.ts file using defineNuxtModule to register the auth module with Nuxt 3.",
            "dependencies": [
              2
            ],
            "details": "Create src/module.ts using defineNuxtModule with proper meta information, implement setup function that adds runtime directory, register composables, add module options interface with typed configuration, set default options, and implement basic hooks for module initialization. Ensure proper TypeScript typing throughout the implementation.",
            "status": "done",
            "testStrategy": "Create a minimal Nuxt 3 test project and verify the module can be imported and initialized without errors."
          },
          {
            "id": 4,
            "title": "Set up build configuration for module distribution",
            "description": "Configure the build system to properly bundle and distribute the Nuxt module for both ESM and CJS compatibility.",
            "dependencies": [
              3
            ],
            "details": "Create build.config.ts using unbuild or similar tool, configure entry points for the module, set up external dependencies, configure output formats (esm, cjs), set up proper exports in package.json for dual package hazard avoidance, configure TypeScript declaration file generation, and ensure source maps are generated for debugging.",
            "status": "done",
            "testStrategy": "Run the build process and verify output files are generated correctly with proper module formats and type declarations."
          },
          {
            "id": 5,
            "title": "Implement CLI entry point for module commands",
            "description": "Create a CLI interface for the module with init and migrate commands to help users set up and maintain the auth system.",
            "dependencies": [
              4
            ],
            "details": "Create src/cli.ts using a CLI framework like commander or yargs, implement 'team-auth init' command to scaffold initial auth configuration, add 'team-auth migrate' command for schema updates, configure bin field in package.json to expose CLI commands, ensure proper error handling and user feedback, and add help text for all commands. Make CLI executable with proper shebang.",
            "status": "done",
            "testStrategy": "Test CLI commands in isolation with mock filesystem to verify they perform expected operations without side effects."
          }
        ]
      },
      {
        "id": 2,
        "title": "Design and Implement Database Schema with RLS Policies",
        "description": "Create PostgreSQL schema for teams, team_members, invites, and impersonation_sessions tables with comprehensive Row Level Security policies",
        "details": "Implement the exact schema from the ERD:\n- teams table: id (uuid), name (text), address (text), vat_number (text), created_at (timestamp)\n- team_members table: team_id (uuid FK), user_id (uuid FK), role (enum: owner|admin|member|super_admin), joined_at (timestamp)\n- invites table: id (uuid), team_id (uuid FK), email (text), token_hash (text), expires_at (timestamp), status (enum: pending|accepted|revoked)\n- impersonation_sessions table: id (uuid), admin_user_id (uuid FK), target_user_id (uuid FK), started_at (timestamp), ended_at (timestamp), reason (text)\n\nRLS Policies:\n- team_members: SELECT for members, INSERT/DELETE for admins/owners within team\n- teams: UPDATE for owners only, SELECT for all team members\n- invites: Full CRUD for admins/owners within team, SELECT for invitee by token\n- impersonation_sessions: Service-role only for INSERT/UPDATE, SELECT for super-admin own sessions",
        "testStrategy": "Database tests for schema creation, RLS policy enforcement, foreign key constraints, and enum validation. Test each policy with different user roles.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Base Database Tables and Enums",
            "description": "Set up the foundational database schema by creating the required tables and enum types according to the ERD specifications.",
            "dependencies": [],
            "details": "Create the following PostgreSQL enum types: 'team_role' (owner, admin, member, super_admin) and 'invite_status' (pending, accepted, revoked). Then create the four tables with proper constraints: teams (with primary key id), team_members (with composite primary key of team_id and user_id), invites (with primary key id), and impersonation_sessions (with primary key id). Ensure all foreign key relationships are properly established.",
            "status": "done",
            "testStrategy": "Verify table creation with \\dt command in psql. Test enum types with sample inserts and validate constraints with intentional violations to ensure they're enforced."
          },
          {
            "id": 2,
            "title": "Implement RLS Policies for Teams Table",
            "description": "Create Row Level Security policies for the teams table to enforce proper access control.",
            "dependencies": [
              1
            ],
            "details": "Enable RLS on the teams table with 'ALTER TABLE teams ENABLE ROW LEVEL SECURITY'. Create policies that allow: 1) SELECT access for all team members (by joining with team_members table), 2) UPDATE access only for team owners, 3) INSERT/DELETE access for service role only. Ensure the policies use the current user context via auth.uid() for user identification.",
            "status": "done",
            "testStrategy": "Test each policy by attempting operations as different user roles. Verify owners can update team details while admins and members cannot. Confirm all team members can view their teams."
          },
          {
            "id": 3,
            "title": "Implement RLS Policies for Team Members Table",
            "description": "Create Row Level Security policies for the team_members table to control membership management.",
            "dependencies": [
              1
            ],
            "details": "Enable RLS on the team_members table. Create policies that allow: 1) SELECT access for members of the same team, 2) INSERT/DELETE access for admins and owners within their team, 3) Full access for super_admins across all teams. Use auth.uid() to identify the current user and join with team_members to determine their role within each team.",
            "status": "done",
            "testStrategy": "Test member visibility within teams. Verify admins can add/remove members while regular members cannot. Confirm super_admins have full access across all teams."
          },
          {
            "id": 4,
            "title": "Implement RLS Policies for Invites Table",
            "description": "Create Row Level Security policies for the invites table to manage team invitation access.",
            "dependencies": [
              1
            ],
            "details": "Enable RLS on the invites table. Create policies that allow: 1) Full CRUD operations for admins and owners within their team, 2) SELECT access for invitees based on their email and token, 3) No access for regular team members. Include a policy for service role access for system-level operations. Ensure proper joins with team_members to verify admin/owner status.",
            "status": "done",
            "testStrategy": "Test invite creation as admins and owners. Verify regular members cannot create or view invites. Test that users can view invites addressed to their email with the correct token."
          },
          {
            "id": 5,
            "title": "Implement RLS Policies for Impersonation Sessions Table",
            "description": "Create Row Level Security policies for the impersonation_sessions table to enforce strict access control for this sensitive feature.",
            "dependencies": [
              1
            ],
            "details": "Enable RLS on the impersonation_sessions table. Create policies that allow: 1) INSERT/UPDATE operations only for the service role, 2) SELECT access for super_admins but only for sessions they initiated (where admin_user_id = auth.uid()), 3) No direct access for regular users, admins, or owners. Add appropriate comments explaining the security implications of these policies.",
            "status": "done",
            "testStrategy": "Test that only the service role can create impersonation sessions. Verify super_admins can only view their own sessions. Confirm regular users, admins, and owners have no access to this table."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Supabase Edge Functions for Core Team Operations",
        "description": "Create all required Supabase Edge Functions for team creation, invitations, role management, and impersonation with proper security",
        "details": "Implement Edge Functions in TypeScript:\n- create_team_and_owner(): Transaction to create team + add owner + issue JWT with team claims\n- accept_invite(): Validate token hash, add user to team, mark invite accepted\n- transfer_ownership(): Change owner role, demote previous owner to admin\n- start_impersonation(): Verify super-admin + MFA, mint 30-min JWT with act_as claims, log session\n- stop_impersonation(): End session, revoke JWT, update ended_at timestamp\n- get_user_emails(): Security-definer function for super-admin email access\n- get_user_email_by_id(): Single email lookup for super-admin\n- admin_login(): Generate magic link + immediate OTP verification for super-admin session restore\n\nImplement email retrieval strategy cascade with single selected method for reliability. Include proper error handling and JWT claim validation.",
        "testStrategy": "Unit tests for each function with mocked Supabase client. Integration tests with real database. Security tests for privilege escalation prevention and MFA enforcement.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Team Creation and Invitation Edge Functions",
            "description": "Create the Edge Functions for team creation and invitation management, including create_team_and_owner() and accept_invite() functions.",
            "dependencies": [],
            "details": "For create_team_and_owner(): Implement a transaction that creates a new team record, adds the creator as owner, and issues a JWT with appropriate team claims. For accept_invite(): Implement token validation logic, add the user to the team with specified role, and mark the invitation as accepted in the database. Both functions should include proper error handling and input validation.",
            "status": "done",
            "testStrategy": "Test with valid and invalid inputs, verify database state after operations, and check JWT claims for correctness. Test edge cases like duplicate team names and expired invitation tokens."
          },
          {
            "id": 2,
            "title": "Implement Role Management Edge Functions",
            "description": "Create the Edge Functions for team role management, specifically the transfer_ownership() function to change team ownership.",
            "dependencies": [],
            "details": "Implement transfer_ownership() to securely change the team owner role. The function should verify the current owner's identity, promote the target user to owner, and demote the previous owner to admin role. Include transaction handling to ensure atomicity of the role changes. Add proper authorization checks to ensure only the current owner can transfer ownership.",
            "status": "done",
            "testStrategy": "Test successful ownership transfers, verify role changes in database, test authorization failures when non-owners attempt transfers, and verify error handling for invalid user IDs."
          },
          {
            "id": 3,
            "title": "Implement User Impersonation Edge Functions",
            "description": "Create the Edge Functions for user impersonation, including start_impersonation() and stop_impersonation() functions.",
            "dependencies": [],
            "details": "For start_impersonation(): Implement verification of super-admin status and MFA completion, then mint a time-limited JWT (30 minutes) with act_as claims, and log the impersonation session. For stop_impersonation(): Implement logic to end the session, revoke the JWT, and update the ended_at timestamp in the session log. Both functions should include comprehensive security checks and audit logging.",
            "status": "done",
            "testStrategy": "Test impersonation lifecycle with valid super-admin credentials, verify JWT claims and expiration, test MFA requirement enforcement, and verify proper session logging and termination."
          },
          {
            "id": 4,
            "title": "Implement Email Retrieval Edge Functions",
            "description": "Create the Edge Functions for email retrieval, including get_user_emails() and get_user_email_by_id() functions with proper security controls.",
            "dependencies": [
              3
            ],
            "details": "Implement get_user_emails() as a security-definer function that allows super-admins to access user emails in bulk. Implement get_user_email_by_id() for single email lookup by super-admins. Both functions should implement the email retrieval strategy cascade for reliability. Add strict authorization checks to ensure only super-admins can access these functions, and implement rate limiting to prevent abuse.",
            "status": "done",
            "testStrategy": "Test authorization controls to verify only super-admins can access emails, test the email retrieval cascade strategy with various scenarios (primary method failure, fallback success), and verify rate limiting effectiveness."
          },
          {
            "id": 5,
            "title": "Implement Admin Authentication and Error Handling",
            "description": "Create the admin_login() Edge Function and implement comprehensive error handling across all functions.",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement admin_login() to generate magic links with immediate OTP verification for super-admin session restoration. Add standardized error handling across all Edge Functions with appropriate HTTP status codes and error messages. Implement JWT claim validation helpers that can be reused across functions. Add logging for security events and errors to facilitate debugging and audit trails.",
            "status": "done",
            "testStrategy": "Test admin login flow with valid and invalid credentials, verify OTP verification works correctly, test error handling with various error conditions across all functions, and verify logs contain appropriate information for debugging and auditing."
          }
        ]
      },
      {
        "id": 4,
        "title": "Create Core Nuxt Composable useTeamAuth with Full API",
        "description": "Implement the main useTeamAuth() composable providing reactive state management, session persistence, dual-session management for impersonation, and state restoration on page reload.",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "high",
        "details": "Create composable with TypeScript interface:\n- Reactive state: currentUser, currentTeam, currentRole, isImpersonating, impersonationExpiresAt\n- Auth methods: signUpWithTeam, signIn, signOut\n- Team management: inviteMember, revokeInvite, resendInvite, promote, demote, transferOwnership\n- Profile: updateProfile, renameTeam, deleteTeam\n- Impersonation: startImpersonation, stopImpersonation\n\nIntegrate with Supabase client, handle JWT claims parsing, implement reactive updates on auth state changes. Include proper error handling with the defined error codes (TEAM_EXISTS, INVITE_EXPIRED, etc.). Implement defensive token storage across four tiers for impersonation sessions.\n\nEnsure session persistence using localStorage or sessionStorage to maintain user state across page reloads. Implement dual-session management to handle both the original user session and the impersonation session concurrently. Restore state appropriately on page reload to maintain a seamless user experience.",
        "testStrategy": "Unit tests for all composable methods, reactive state updates, session persistence, dual-session management, and error handling. Integration tests with Supabase Edge Functions. E2E tests for complete user flows, including state restoration on page reload.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Core State and Type Definitions",
            "description": "Create the foundation for useTeamAuth composable by defining TypeScript interfaces, reactive state, and initial setup with Supabase client.",
            "dependencies": [],
            "details": "1. Define TypeScript interfaces for all state objects (User, Team, Role, etc.)\n2. Create reactive state using Vue's ref/reactive for currentUser, currentTeam, currentRole, isImpersonating, impersonationExpiresAt\n3. Set up Supabase client integration\n4. Implement JWT claims parsing utility\n5. Create the basic composable structure with state initialization\n6. Add state reset functionality for sign-out",
            "status": "done",
            "testStrategy": "Unit test the state initialization, reset functionality, and JWT parsing utility."
          },
          {
            "id": 2,
            "title": "Implement Authentication Methods",
            "description": "Add core authentication methods to the composable: signUpWithTeam, signIn, and signOut with proper error handling.",
            "dependencies": [],
            "details": "1. Implement signUpWithTeam method that creates both user and team records\n2. Implement signIn method with email/password authentication\n3. Implement signOut method that clears state and Supabase session\n4. Add proper error handling with defined error codes (TEAM_EXISTS, etc.)\n5. Ensure reactive state updates after auth operations\n6. Implement auth state change listener to keep state in sync",
            "status": "done",
            "testStrategy": "Test each auth method with mock Supabase responses, verify error handling for various scenarios."
          },
          {
            "id": 3,
            "title": "Implement Team Management Methods",
            "description": "Add team management functionality: inviteMember, revokeInvite, resendInvite, promote, demote, and transferOwnership.",
            "dependencies": [],
            "details": "1. Implement inviteMember with email validation and role specification\n2. Add revokeInvite method to cancel pending invitations\n3. Implement resendInvite for expired invitations\n4. Create promote/demote methods for changing member roles\n5. Implement transferOwnership with confirmation checks\n6. Add proper permission validation for each operation\n7. Ensure reactive state updates after team changes",
            "status": "done",
            "testStrategy": "Test each team management method with various permission scenarios, verify state updates."
          },
          {
            "id": 4,
            "title": "Implement Profile and Team Settings Methods",
            "description": "Add methods for managing user profile and team settings: updateProfile, renameTeam, and deleteTeam.",
            "dependencies": [],
            "details": "1. Implement updateProfile method for changing user details\n2. Add renameTeam method with validation\n3. Implement deleteTeam with proper confirmation and cleanup\n4. Add permission checks for team operations\n5. Ensure reactive state updates after profile/team changes\n6. Implement proper error handling for each operation",
            "status": "done",
            "testStrategy": "Test each method with various scenarios including permission errors, validation failures."
          },
          {
            "id": 5,
            "title": "Implement Impersonation System",
            "description": "Add user impersonation functionality with multi-tiered token storage: startImpersonation and stopImpersonation.",
            "dependencies": [
              4
            ],
            "details": "1. Implement four-tier token storage system for impersonation sessions\n2. Create startImpersonation method with proper permission checks\n3. Add stopImpersonation method to revert to original user\n4. Implement expiration handling for impersonation sessions\n5. Add reactive state updates for isImpersonating and impersonationExpiresAt\n6. Ensure proper cleanup of tokens when impersonation ends\n7. Add security measures to prevent privilege escalation",
            "status": "done",
            "testStrategy": "Test impersonation lifecycle, token storage, expiration handling, and security constraints."
          },
          {
            "id": 6,
            "title": "Implement Session Persistence and State Restoration",
            "description": "Ensure session persistence using localStorage/sessionStorage and implement state restoration on page reload.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "1. Implement session persistence by storing relevant state in localStorage or sessionStorage\n2. Restore state from storage on page reload to maintain user session\n3. Handle synchronization between reactive state and stored session data\n4. Ensure security measures are in place to protect stored session data\n5. Test session persistence and state restoration across various scenarios",
            "status": "done",
            "testStrategy": "Test session persistence and state restoration functionality, including edge cases such as manual clearing of storage or session expiration."
          },
          {
            "id": 7,
            "title": "Implement Dual-Session Management for Impersonation",
            "description": "Manage concurrent sessions for both the original user and the impersonated user during impersonation.",
            "dependencies": [
              5,
              6
            ],
            "details": "1. Implement mechanisms to maintain both original and impersonation sessions concurrently\n2. Ensure seamless switching between sessions without data loss\n3. Handle session expiration and cleanup for both sessions appropriately\n4. Implement security measures to prevent unauthorized access to either session\n5. Test dual-session management across various impersonation scenarios",
            "status": "done",
            "testStrategy": "Test dual-session management functionality, including session switching, expiration handling, and security constraints."
          }
        ]
      },
      {
        "id": 5,
        "title": "Build Vue 3 UI Components Using Nuxt UI Primitives",
        "description": "Create all required Vue 3 components using only Nuxt UI open-source primitives as specified in the component mapping.",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "medium",
        "details": "Implement components using specified Nuxt UI primitives:\n- <AuthSignIn> & <AuthSignUpWithTeam>: Use UCard, UFormField, UInput, UButton\n- <UserButton>: Use UAvatar, UDropdownMenu for user menu\n- <ProfileForm>: Use UCard, UFormField, UInput, UButton for profile editing\n- <TeamMembersTable>: Use UTable, UBadge for role display\n- <TeamSettingsModal>: Use UModal, UFormField, UInput, UButton\n- <SignedIn> & <SignedOut>: Thin wrappers with v-if using isSignedIn from useTeamAuth\n\nEnsure WCAG 2.1 AA compliance, keyboard navigation, screen reader support. Expose slots and props for customization. Include impersonation banner component with countdown timer.",
        "testStrategy": "Component tests with Vue Test Utils, accessibility tests with @vue/test-utils and axe-core, visual regression tests, keyboard navigation tests.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Authentication Components",
            "description": "Create the <AuthSignIn> and <AuthSignUpWithTeam> components using Nuxt UI primitives for user authentication flows.",
            "dependencies": [],
            "details": "Use UCard as the container for both components. Implement form fields with UFormField and UInput for username/email, password, and team name (for signup). Add validation with appropriate error messages. Use UButton for submit actions with loading states. Ensure both components emit appropriate events (success, error) and integrate with the useTeamAuth composable. Include 'forgot password' link in the sign-in component. Ensure tab order is logical for keyboard navigation.",
            "status": "done",
            "testStrategy": "Test with various input combinations, validation errors, and success states. Verify ARIA attributes and keyboard navigation. Test screen reader announcements for form errors."
          },
          {
            "id": 2,
            "title": "Create User Profile Components",
            "description": "Implement the <UserButton> dropdown and <ProfileForm> components for user profile management.",
            "dependencies": [],
            "details": "For <UserButton>: Use UAvatar to display user profile image with fallback to initials. Implement UDropdownMenu with menu items for profile, settings, team management, and logout. For <ProfileForm>: Create a form using UCard, UFormField, and UInput for name, email, and profile image upload. Add validation and error handling. Use UButton for save/cancel actions with appropriate loading states. Both components should use data from useTeamAuth composable. Ensure proper focus management when opening/closing dropdowns.\n<info added on 2025-06-16T09:39:52.163Z>\n**UserButton Component:**\n- Created with UAvatar and UDropdown primitives\n- Role-based dropdown menu (different items for member/admin/super_admin)\n- Integrated with useTeamAuth composable (currentUser, currentRole, signOut)\n- Avatar with fallback to user initials\n- Proper event emission for profile/teamSettings/impersonation actions\n- Accessibility attributes and keyboard navigation support\n\n**ProfileForm Component:**\n- Created with UCard, UFormField, UInput, UButton primitives\n- Complete profile editing: name, email (readonly), avatar upload, password change\n- MFA toggle functionality with UToggle\n- Form validation using Valibot schema\n- File upload for avatar with 2MB size limit and preview\n- Change detection and form reset functionality\n- Integration with useTeamAuth.updateProfile method\n- Loading states and error/success messaging\n\n**Playground Testing:**\n- Both components added to playground and working\n- Proper Nuxt UI v3 styling matching existing components\n- All interactive elements functioning correctly\n- ClientOnly wrapper with loading fallbacks\n\nBoth components are production-ready and follow all PRD requirements (FR-5, FR-6). Ready to proceed with Team Management Components (subtask 5.3).\n</info added on 2025-06-16T09:39:52.163Z>",
            "status": "done",
            "testStrategy": "Test dropdown opening/closing, menu item selection, and form submission flows. Verify form validation and error states. Test keyboard navigation through dropdown menu items.",
            "subtasks": [
              {
                "id": 6,
                "title": "Test User Profile Components in Playground",
                "description": "Integrate and test the <UserButton> and <ProfileForm> components within the Nuxt UI v3 playground environment to ensure proper styling and functionality.",
                "dependencies": [],
                "details": "Add the <UserButton> and <ProfileForm> components to the playground. Verify that they render correctly with Nuxt UI styling. Test all interactive elements for proper behavior, including dropdown interactions and form submissions. Ensure that all components are responsive and accessible.",
                "status": "pending",
                "testStrategy": "Manual testing within the playground environment to verify component rendering, styling, and functionality. Automated tests for accessibility and responsiveness."
              }
            ]
          },
          {
            "id": 3,
            "title": "Develop Team Management Components",
            "description": "Build the <TeamMembersTable> and <TeamSettingsModal> components for team administration.",
            "dependencies": [],
            "details": "For <TeamMembersTable>: Implement UTable with columns for user details, role (using UBadge with appropriate colors), and actions. Include pagination, sorting, and filtering capabilities. Add row actions for role changes and member removal. For <TeamSettingsModal>: Create a modal using UModal with tabs for general settings, billing, and permissions. Use UFormField and UInput for form fields. Implement save/cancel actions with UButton. Ensure proper focus trapping within the modal and restore focus on close.",
            "status": "done",
            "testStrategy": "Test table sorting, filtering, and pagination. Verify role changes and member removal flows. Test modal opening/closing, tab switching, and form submission. Verify focus management and keyboard navigation within the modal.",
            "subtasks": [
              {
                "id": 7,
                "title": "Test Team Management Components in Playground",
                "description": "Integrate and test the <TeamMembersTable> and <TeamSettingsModal> components within the Nuxt UI v3 playground environment to ensure proper styling and functionality.",
                "dependencies": [],
                "details": "Add the <TeamMembersTable> and <TeamSettingsModal> components to the playground. Verify that they render correctly with Nuxt UI styling. Test all interactive elements for proper behavior, including table interactions and modal dialogs. Ensure that all components are responsive and accessible.",
                "status": "pending",
                "testStrategy": "Manual testing within the playground environment to verify component rendering, styling, and functionality. Automated tests for accessibility and responsiveness."
              }
            ]
          },
          {
            "id": 4,
            "title": "Implement Authentication State Components",
            "description": "Create the <SignedIn> and <SignedOut> wrapper components and the impersonation banner with countdown timer.",
            "dependencies": [],
            "details": "For <SignedIn> and <SignedOut>: Create thin wrapper components that conditionally render their slots based on authentication state from useTeamAuth. For the impersonation banner: Create a fixed position banner that appears when a user is being impersonated. Include user details, a countdown timer showing remaining session time, and an 'End Session' button. Use UButton and implement a reactive countdown timer. Ensure the banner is announced to screen readers appropriately.\n<info added on 2025-06-18T17:57:25.008Z>\nCompleted the implementation of `<SignedIn>` and `<SignedOut>` components. These components are thin wrappers that conditionally render their slot content based on the `currentUser` from the `useTeamAuth` composable. They are available via auto-import and have been tested in the playground. The impersonation banner will be addressed separately in Task 6.\n</info added on 2025-06-18T17:57:25.008Z>",
            "status": "done",
            "testStrategy": "Test conditional rendering based on authentication state changes. Verify the countdown timer updates correctly and ends session at zero. Test keyboard accessibility of the impersonation banner and screen reader announcements.",
            "subtasks": [
              {
                "id": 8,
                "title": "Test Authentication State Components in Playground",
                "description": "Integrate and test the <SignedIn>, <SignedOut>, and impersonation banner components within the Nuxt UI v3 playground environment to ensure proper styling and functionality.",
                "dependencies": [],
                "details": "Add the <SignedIn>, <SignedOut>, and impersonation banner components to the playground. Verify that they render correctly with Nuxt UI styling. Test all interactive elements for proper behavior, including conditional rendering and countdown timer functionality. Ensure that all components are responsive and accessible.",
                "status": "pending",
                "testStrategy": "Manual testing within the playground environment to verify component rendering, styling, and functionality. Automated tests for accessibility and responsiveness."
              }
            ]
          },
          {
            "id": 5,
            "title": "Ensure Accessibility and Component Customization",
            "description": "Review and enhance all components for WCAG 2.1 AA compliance and implement customization options through props and slots.",
            "dependencies": [],
            "details": "Audit all components for accessibility issues: ensure proper contrast ratios, keyboard navigation, focus indicators, and ARIA attributes. Test with screen readers. For customization: Add props for theming (colors, sizes, variants) to all components. Implement named slots for content customization (e.g., custom header/footer in cards, custom cell rendering in tables). Document all available props and slots. Create a consistent API across components. Ensure responsive behavior on all screen sizes.",
            "status": "done",
            "testStrategy": "Run automated accessibility tests (e.g., axe-core). Perform manual testing with keyboard-only navigation and screen readers. Test customization options by creating variant examples of each component with different props and slot content.",
            "subtasks": [
              {
                "id": 9,
                "title": "Test Component Accessibility and Customization in Playground",
                "description": "Integrate and test all components within the Nuxt UI v3 playground environment to ensure accessibility compliance and verify customization options.",
                "dependencies": [],
                "details": "Add all components to the playground. Verify that they meet WCAG 2.1 AA compliance standards. Test customization options through props and slots to ensure flexibility and consistency. Ensure that all components are responsive and accessible.",
                "status": "pending",
                "testStrategy": "Manual testing within the playground environment to verify accessibility compliance and customization options. Automated tests for accessibility and responsiveness."
              }
            ]
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Impersonation System with Security Controls",
        "description": "Build complete impersonation functionality with JWT-based session management, MFA enforcement, and audit logging",
        "details": "Implement Pattern A (Short-Lived JWT):\n- 30-minute JWT sessions with act_as claims\n- MFA re-prompt for super-admin before impersonation start\n- Session storage in Nuxt with automatic reload on context switch\n- Impersonation banner component with countdown and stop button\n- Auto-expiry handling with graceful fallback to admin context\n- Complete audit trail in impersonation_sessions table\n- Block admin routes when act_as=true to prevent privilege blending\n- Defensive token storage across server-verified, client-verified, storage restore, and manual tiers",
        "testStrategy": "Security tests for MFA enforcement, privilege separation, session expiry. Audit tests for complete logging. Integration tests for session management and context switching.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement JWT Token Generation with act_as Claims",
            "description": "Create the backend functionality to generate short-lived JWT tokens with act_as claims for impersonation sessions",
            "dependencies": [],
            "details": "Modify the authentication service to include act_as claims in JWT tokens. Implement token generation with 30-minute expiration. Create endpoints for starting impersonation that validates super-admin permissions and enforces MFA verification before generating the impersonation token. Ensure the token includes the impersonated user's ID, the admin's original ID, and appropriate scope limitations.",
            "status": "done",
            "testStrategy": "Unit test token generation with various user combinations. Integration test the MFA verification flow. Verify token expiration works correctly."
          },
          {
            "id": 2,
            "title": "Develop Session Management for Impersonation Context",
            "description": "Implement client-side session management to handle impersonation tokens, context switching, and automatic reload",
            "dependencies": [
              1
            ],
            "details": "Create a Nuxt plugin for managing impersonation sessions. Implement secure token storage with multiple verification tiers (server-verified, client-verified, storage restore, manual). Add functionality to detect token expiration and handle automatic reload when switching between admin and impersonated user contexts. Implement graceful fallback to admin context when impersonation expires.",
            "status": "done",
            "testStrategy": "Test session persistence across page reloads. Verify context switching works correctly. Test expiration handling and fallback mechanisms."
          },
          {
            "id": 3,
            "title": "Create Impersonation Banner Component with Countdown",
            "description": "Develop a UI component that displays when impersonation is active, showing session details, countdown timer, and stop functionality",
            "dependencies": [
              2
            ],
            "details": "Build a persistent banner component that appears across all pages when impersonation is active. Include a countdown timer showing remaining session time, the name of the impersonated user, and a prominent stop button to end impersonation. Ensure the banner is visually distinct and cannot be dismissed while impersonation is active. Implement real-time countdown that updates every minute.",
            "status": "done",
            "testStrategy": "Test banner visibility across different pages. Verify countdown accuracy. Test stop functionality properly ends the session."
          },
          {
            "id": 4,
            "title": "Implement Route Protection and Privilege Separation",
            "description": "Add security controls to prevent privilege blending by blocking admin routes during impersonation",
            "dependencies": [
              2
            ],
            "details": "Modify the router middleware to check for act_as claims in the current token. Block access to all admin routes when impersonation is active to prevent privilege blending. Implement appropriate error handling and user feedback when blocked routes are attempted. Create a mechanism to temporarily exit impersonation for specific admin actions if needed, with MFA re-verification.",
            "status": "done",
            "testStrategy": "Test route protection by attempting to access admin routes during impersonation. Verify appropriate redirects and error messages. Test temporary exit mechanism if implemented."
          },
          {
            "id": 5,
            "title": "Develop Comprehensive Audit Logging System",
            "description": "Create a complete audit trail for all impersonation activities in the impersonation_sessions table",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Design and implement the impersonation_sessions database table to track all impersonation events. Log the start and end of each session, including admin ID, impersonated user ID, timestamp, duration, IP address, and reason for impersonation. Add endpoints to record session events. Implement automatic logging when sessions expire naturally or are manually ended. Create an admin interface to review the audit logs with filtering and search capabilities.",
            "status": "done",
            "testStrategy": "Verify all impersonation events are properly logged. Test both manual session termination and automatic expiration logging. Validate the admin interface displays accurate log information."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Email System with Magic Link Strategy",
        "description": "Build robust email delivery system with magic link authentication and configurable SMTP options",
        "status": "pending",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "details": "Implement email system:\n- Single pre-selected email retrieval strategy for reliability (no configuration required)\n- Magic link generation for invitations with 7-day expiry\n- Magic link impersonation flow: generate without sending, immediate OTP verification\n- Integration with Supabase SMTP or custom transporter option\n- Email templates for invitations, role changes, team updates\n- Graceful degradation with cascading fallbacks for auth errors\n- User-friendly error messages and partial success handling\n- Secure token hashing for invite links\n- Complete invitation backend using Supabase's auth.admin.inviteUserByEmail()\n- Admin UI for managing pending invitations in TeamForm.vue\n- Display table for pending invitations with status\n- Revoke and resend invitation functionality",
        "testStrategy": "Email delivery tests with test SMTP server, magic link validation tests, token security tests, template rendering tests, fallback mechanism tests. Test complete invitation flow from sending invite to team membership completion. Verify UI functionality for managing pending invitations, including display, revoke, and resend features.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement SMTP Configuration and Email Transport Layer",
            "description": "Create a configurable email transport layer that supports both Supabase SMTP and custom SMTP options with fallback mechanisms",
            "dependencies": [],
            "details": "Create an EmailTransporter class that handles SMTP configuration. Implement a strategy pattern to support different email providers with Supabase as default. Add configuration validation, connection testing, and cascading fallbacks between providers when delivery fails. Include error logging and monitoring capabilities.",
            "status": "done",
            "testStrategy": "Unit test each transport strategy with mocked SMTP services. Integration tests should verify fallback mechanisms work when primary delivery fails."
          },
          {
            "id": 2,
            "title": "Develop Magic Link Token Generation and Validation",
            "description": "Create secure token generation for magic links with proper hashing, expiration handling, and validation logic",
            "dependencies": [],
            "details": "Implement a TokenService that generates cryptographically secure tokens with configurable expiration (default 7 days). Store hashed tokens in the database with creation timestamp and expiry date. Create validation methods to verify token authenticity and check expiration status. Implement token revocation functionality for security.",
            "status": "done",
            "testStrategy": "Test token generation uniqueness, proper hashing implementation, expiration validation, and token revocation. Include security-focused tests to ensure tokens cannot be tampered with."
          },
          {
            "id": 3,
            "title": "Create Email Template System with Standard Templates",
            "description": "Build a template engine for emails with standard templates for invitations, role changes, and team updates",
            "dependencies": [],
            "details": "Implement a TemplateEngine class that supports HTML and text email formats. Create base templates for all required email types (invitations, role changes, team updates). Include personalization variables, styling consistent with application branding, and responsive design. Ensure templates are accessible and render properly across email clients.",
            "status": "done",
            "testStrategy": "Verify template rendering with various input data. Test email rendering in multiple email clients. Validate HTML structure and accessibility."
          },
          {
            "id": 4,
            "title": "Implement Magic Link Invitation Flow",
            "description": "Build the end-to-end invitation flow using magic links, including generation, delivery, and user acceptance",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create an InvitationService that generates magic links using the TokenService. Implement email sending via the EmailTransporter with appropriate templates. Add endpoints for accepting invitations and verifying tokens. Include special handling for impersonation flow with OTP verification. Implement proper error handling and user feedback for failed invitations.",
            "status": "done",
            "testStrategy": "End-to-end testing of the invitation flow from generation to acceptance. Test expiration handling, invalid token scenarios, and the impersonation flow with OTP verification."
          },
          {
            "id": 5,
            "title": "Implement Error Handling and Monitoring System",
            "description": "Create comprehensive error handling for the email system with user-friendly messages and monitoring",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement a centralized error handling system for all email operations. Create user-friendly error messages for common failure scenarios. Add detailed logging for debugging purposes. Implement metrics collection for monitoring email delivery success rates, timing, and error frequencies. Create an admin dashboard component to display system health and recent email activity.",
            "status": "done",
            "testStrategy": "Test error scenarios including network failures, invalid email addresses, and template rendering issues. Verify logs contain appropriate debugging information and error messages are user-friendly."
          },
          {
            "id": 6,
            "title": "Create /accept-invite Page and Route",
            "description": "Develop the frontend page and route for accepting invitations using the existing TeamAuthConfirmation component",
            "dependencies": [
              4
            ],
            "details": "Implement the /accept-invite page using the TeamAuthConfirmation component. Ensure the page is styled consistently with the rest of the application and handles all necessary user interactions for accepting an invitation.",
            "status": "pending",
            "testStrategy": "Test the page rendering and user interactions in various browsers. Verify that the page correctly integrates with the backend to complete the invitation acceptance process."
          },
          {
            "id": 7,
            "title": "Wire up acceptInvite() Method",
            "description": "Integrate the acceptInvite() method from useTeamAuth into the /accept-invite page",
            "dependencies": [
              6
            ],
            "details": "Ensure that the acceptInvite() method is correctly called when a user accepts an invitation on the /accept-invite page. Handle any errors and provide user feedback as necessary.",
            "status": "pending",
            "testStrategy": "Test the integration by simulating invitation acceptance and verifying that the user is correctly added to the team. Check for proper error handling and user feedback."
          },
          {
            "id": 8,
            "title": "Test Complete Invitation Flow",
            "description": "Conduct comprehensive testing of the invitation flow from sending an invite to team membership completion",
            "dependencies": [
              7
            ],
            "details": "Perform end-to-end testing of the entire invitation process, including sending invitations, accepting them via the /accept-invite page, and verifying team membership completion.",
            "status": "pending",
            "testStrategy": "Use a test environment to simulate the entire invitation flow. Verify that all steps function correctly and that users are successfully added to teams. Check for any issues in the flow and ensure all components work together seamlessly."
          },
          {
            "id": 9,
            "title": "Add Pending Invitation Management to Admin UI",
            "description": "Enhance the TeamForm.vue component to manage pending invitations",
            "dependencies": [
              4
            ],
            "details": "Implement a display table in TeamForm.vue to show pending invitations with their current status. Add functionality to revoke or resend invitations directly from the UI. Ensure the UI is intuitive and provides real-time updates on invitation status.",
            "status": "pending",
            "testStrategy": "Test the UI for displaying pending invitations, revoking, and resending functionality. Verify that actions are correctly reflected in the backend and that the UI updates in real-time."
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement Role-Based Access Control and Permissions",
        "description": "Build comprehensive RBAC system with role hierarchy, permission checks, and secure role transitions",
        "details": "RBAC Implementation:\n- Role hierarchy: super_admin > owner > admin > member\n- Permission matrix for all operations (invite, promote, demote, delete, etc.)\n- Secure role transition validation (owner transfer, promotion/demotion rules)\n- Frontend permission guards for UI elements\n- Backend permission validation in Edge Functions\n- Role-based route protection middleware\n- Cascading team deletion with owner-only access\n- Prevention of self-demotion and orphaned teams\n- Integration with JWT claims for real-time permission checks",
        "testStrategy": "Permission matrix tests for all role combinations, role transition security tests, UI permission guard tests, backend authorization tests, edge case handling (self-operations, last owner scenarios).",
        "priority": "high",
        "dependencies": [
          4,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Role Hierarchy and Permission Matrix",
            "description": "Create the foundational data structures for the RBAC system by defining the role hierarchy and comprehensive permission matrix for all operations.",
            "dependencies": [],
            "details": "1. Define enum/constants for roles (super_admin, owner, admin, member)\n2. Create a hierarchical relationship map between roles\n3. Define all system operations (invite, promote, demote, delete, etc.)\n4. Build a permission matrix mapping roles to allowed operations\n5. Document the role hierarchy and permission rules\n6. Create utility functions to check if a role is higher than another",
            "status": "done",
            "testStrategy": "Unit tests for role comparison functions and permission matrix validation to ensure logical consistency in role hierarchy."
          },
          {
            "id": 2,
            "title": "Implement Backend Permission Validation",
            "description": "Build the server-side validation logic in Edge Functions to enforce permission checks based on the defined role hierarchy and permission matrix.",
            "dependencies": [
              1
            ],
            "details": "1. Create middleware for extracting user roles from JWT claims\n2. Implement permission validation functions using the permission matrix\n3. Build role transition validation logic (promotion/demotion rules)\n4. Create owner transfer validation with security checks\n5. Implement prevention of self-demotion logic\n6. Add validation to prevent orphaned teams\n7. Create reusable permission check decorators/wrappers for Edge Functions",
            "status": "done",
            "testStrategy": "Integration tests with mock JWT tokens to verify permission enforcement and role transition validation."
          },
          {
            "id": 3,
            "title": "Develop Role-Based Route Protection",
            "description": "Create middleware for protecting routes based on user roles and implement cascading team deletion with owner-only access.",
            "dependencies": [
              2
            ],
            "details": "1. Develop middleware to protect routes based on required role level\n2. Implement cascading team deletion logic with owner-only access checks\n3. Create helper functions to validate user permissions for specific resources\n4. Add logging for permission denials and role changes for audit purposes\n5. Implement rate limiting for sensitive role operations\n6. Create error handlers for unauthorized access attempts",
            "status": "done",
            "testStrategy": "API tests with different user roles to verify proper route protection and resource access control."
          },
          {
            "id": 4,
            "title": "Implement Frontend Permission Guards",
            "description": "Create UI permission guards to conditionally render elements and actions based on the user's role and permissions.",
            "dependencies": [
              1
            ],
            "details": "1. Create a client-side permission utility to check user permissions\n2. Implement conditional rendering for UI elements based on permissions\n3. Add disabled states for actions not allowed for current role\n4. Create higher-order components or hooks for permission-based rendering\n5. Implement tooltips explaining why actions are unavailable\n6. Add visual indicators of user's current role in the UI",
            "status": "done",
            "testStrategy": "Component tests with different user roles to verify correct UI rendering and interaction permissions."
          },
          {
            "id": 5,
            "title": "Integrate JWT Claims for Real-Time Permission Checks",
            "description": "Connect the RBAC system with JWT authentication to enable real-time permission checks and role updates.",
            "dependencies": [
              2,
              4
            ],
            "details": "1. Update JWT payload structure to include role and permission data\n2. Implement JWT refresh logic to update permissions after role changes\n3. Create a permission context provider for the frontend\n4. Add real-time permission validation on both client and server\n5. Implement secure storage of permission data\n6. Add event listeners for role changes to trigger permission updates\n7. Create comprehensive documentation for the RBAC implementation",
            "status": "done",
            "testStrategy": "End-to-end tests simulating role changes and verifying permission updates propagate correctly throughout the system."
          }
        ]
      },
      {
        "id": 17,
        "title": "Set up Local Supabase Development Environment",
        "description": "Configure a local Supabase development environment with database initialization, environment variables, and development tooling for the team-auth module.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "Set up comprehensive local Supabase development environment:\n\n✅ **COMPLETED - Initialize Supabase Project**:\n   - ✅ Run `supabase init` in the module root directory\n   - ✅ Configure supabase/config.toml with appropriate settings for local development (MFA TOTP and email confirmations enabled)\n   - ✅ Set up project structure with supabase/ directory containing migrations, functions, and seed data\n\n⏳ **IN PROGRESS - Local Database Configuration**:\n   - ✅ Install and configure Docker for local PostgreSQL instance\n   - ⏳ Docker images currently downloading for Supabase services (postgres, auth, api, studio, etc.)\n   - ⏳ Run `supabase start` to spin up local development stack (pending Docker download completion)\n   - ⏳ Configure database connection settings for local development\n   - ⏳ Set up initial database schema for team authentication (users, teams, roles, permissions tables)\n\n✅ **COMPLETED - Environment Configuration**:\n   - ✅ Create .env.example template with all required Supabase variables\n   - ✅ Set up .env.local for local development (ready for API keys once services start)\n   - ⏳ Populate .env.local with actual API keys from running Supabase instance\n   - ⏳ Configure environment variable validation and type safety\n\n✅ **COMPLETED - Development Tooling Setup**:\n   - ✅ Configure Supabase CLI commands in package.json scripts (start, stop, reset, status, migrate, generate-types)\n   - ✅ Set up database migration workflow\n   - ✅ Configure local testing database reset/seed procedures\n   - ✅ Set up src/runtime/types directory for TypeScript type generation\n   - ⏳ Generate initial TypeScript types from database schema\n\n✅ **COMPLETED - Documentation**:\n   - ✅ Created SETUP.md with comprehensive local development instructions\n\n⏳ **PENDING - Integration with Module Structure**:\n   - ⏳ Ensure Supabase configuration works with Nuxt 3 module structure\n   - ⏳ Set up proper imports and exports for Supabase client\n   - ⏳ Configure development vs production environment handling",
        "testStrategy": "Verify local Supabase environment setup:\n\n1. **Environment Validation**:\n   - Confirm `supabase status` shows all services running (PostgreSQL, Auth, API, etc.)\n   - Verify .env files contain all required variables with correct local values\n   - Test environment variable loading in development mode\n\n2. **Database Connectivity**:\n   - Successfully connect to local PostgreSQL instance using provided credentials\n   - Verify Supabase client can authenticate with local anon and service role keys\n   - Test basic database operations (SELECT, INSERT) through Supabase client\n\n3. **Development Workflow**:\n   - Run `supabase db reset` and verify clean database state\n   - Test migration application and rollback procedures\n   - Verify local development server can access Supabase services without errors\n\n4. **Module Integration**:\n   - Confirm Nuxt 3 module can import and use Supabase client in development\n   - Test that TypeScript types are properly generated and accessible\n   - Verify no conflicts between Supabase configuration and module structure\n\n5. **Documentation Verification**:\n   - Ensure setup instructions are complete and reproducible\n   - Verify all required dependencies and prerequisites are documented\n   - Test setup process on clean environment to confirm completeness",
        "subtasks": [
          {
            "id": "17.1",
            "title": "Complete Docker image download and start Supabase services",
            "description": "Wait for Docker images to finish downloading, then start the local Supabase stack",
            "status": "done"
          },
          {
            "id": "17.2",
            "title": "Capture and configure API keys",
            "description": "Once Supabase services are running, capture the local API keys and populate .env.local file",
            "status": "done"
          },
          {
            "id": "17.3",
            "title": "Set up initial database schema",
            "description": "Create initial database schema for team authentication (users, teams, roles, permissions tables)",
            "status": "done"
          },
          {
            "id": "17.4",
            "title": "Generate TypeScript types",
            "description": "Run type generation to create TypeScript definitions from the database schema",
            "status": "done"
          },
          {
            "id": "17.5",
            "title": "Configure environment variable validation",
            "description": "Set up environment variable validation and type safety for the module",
            "status": "done"
          },
          {
            "id": "17.6",
            "title": "Integrate with Nuxt 3 module structure",
            "description": "Ensure Supabase configuration works properly with the Nuxt 3 module structure and set up client imports/exports",
            "status": "done"
          }
        ]
      },
      {
        "id": 19,
        "title": "Session Management System",
        "description": "Implement robust session management with token refresh, persistence, and cleanup",
        "details": "Add functionality to handle user sessions including automatic token refresh, session persistence across browser refreshes, and proper session cleanup on logout",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Token Refresh Logic",
            "description": "Create automatic token refresh mechanism to handle expired JWT tokens",
            "details": "Build logic to detect token expiration and automatically refresh tokens before they expire",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 19
          }
        ]
      },
      {
        "id": 21,
        "title": "Implement Critical RLS Security Policies",
        "description": "Create Row Level Security policies for all tables - this is currently missing and represents a major security vulnerability. Implement team-scoped access control for teams, team_members, invites, and impersonation_sessions tables.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Create Universal Confirmation Handler",
        "description": "Implement a single confirmation page that handles both email confirmation after signup AND invitation acceptance, following the pattern from the reference implementation. Include hash parameter fallback for email clients that strip query strings.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Session Persistence and State Management",
        "description": "Add localStorage and sessionStorage integration for session persistence across page reloads. Implement proper session restoration and state hydration for the useTeamAuth composable, including impersonation context preservation.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Create Authentication Middleware and Route Protection",
        "description": "Implement Nuxt middleware for route protection based on authentication status and user roles. Add global authentication checks and redirection logic for protected routes.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          4,
          21
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Write Tests for Authentication Middleware",
            "description": "Create comprehensive unit and integration tests for all middleware functions including authentication checks, role-based access control, team membership verification, and redirection logic. Test both positive and negative scenarios.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 24
          }
        ]
      },
      {
        "id": 25,
        "title": "Create Helper Functions for Secure Database Operations",
        "description": "Implement SQL helper functions with SECURITY DEFINER for safe privilege escalation and team context scoping. Add functions for current_user_team(), user role checks, and other database utilities needed for RLS policies.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          21
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Enhance Invitation System with Better Tracking",
        "description": "Improve the invites table to include status tracking (accepted_at, expires_at fields), custom token storage for fallback scenarios, and better audit trails while preserving our simplified auth.admin.inviteUserByEmail() approach.",
        "details": "",
        "testStrategy": "",
        "status": "cancelled",
        "dependencies": [
          3,
          21
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Add User Profile Storage and Management",
        "description": "Create a users profile table or extend auth.users metadata to store user information like first_name, last_name, and other profile data. This enables better user management and profile features.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          21
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Set Up Testing Infrastructure and Framework",
        "description": "Configure comprehensive testing environment with Vitest for unit tests, Playwright for E2E tests, and testing utilities for Nuxt composables and Edge Functions. Set up test databases, mocking strategies, and CI/CD integration following TDD best practices.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Vitest for Unit Testing",
            "description": "Set up Vitest as the primary unit testing framework with TypeScript support, Vue component testing utilities, and mocking capabilities for Supabase clients",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 28
          },
          {
            "id": 2,
            "title": "Set Up Playwright for E2E Testing",
            "description": "Configure Playwright for end-to-end testing with cross-browser support, test database setup/teardown, and Supabase local environment integration",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 28
          },
          {
            "id": 3,
            "title": "Create Test Database Setup and Helpers",
            "description": "Create test database utilities for seeding data, cleaning up between tests, and managing test user accounts. Include helpers for creating test teams and users with different roles",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 28
          },
          {
            "id": 4,
            "title": "Configure CI/CD Test Pipeline",
            "description": "Set up GitHub Actions workflow for automated testing including unit tests, integration tests, and E2E tests with coverage reporting and performance benchmarks",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 28
          }
        ]
      },
      {
        "id": 29,
        "title": "Write Unit Tests for useTeamAuth Composable",
        "description": "Implement comprehensive unit tests for the useTeamAuth composable using a Test-Driven Development (TDD) approach. Focus on testing all methods, including signUpWithTeam, signIn, signOut, team management, and impersonation. Ensure coverage of input/output pairs, error scenarios, and state management, with particular attention to session persistence and dual-session handling.",
        "status": "done",
        "dependencies": [
          4,
          28
        ],
        "priority": "high",
        "details": "Significant progress has been made in developing the useTeamAuth composable with a focus on testability through dependency injection. Key issues such as session state initialization, JWT parsing, and asynchronous timing have been addressed. Currently, 14 out of 17 tests are passing, achieving an 82% success rate. The remaining three tests are encountering minor issues related to mock setup. The core business logic has been validated, covering areas like state management, JWT claims parsing, authentication orchestration, error handling, permission checks, team management, and impersonation validation. External dependencies, including Supabase API calls and browser storage APIs, are being appropriately mocked.",
        "testStrategy": "Continue refining the unit tests to achieve full coverage and resolve the remaining mock setup issues. Ensure that all tests accurately reflect the intended behavior of the useTeamAuth composable, particularly focusing on the areas where issues have been identified. Maintain the use of dependency injection to facilitate testability and mock external dependencies as needed.",
        "subtasks": [
          {
            "id": 1,
            "title": "Resolve Mock Setup Issues in Remaining Tests",
            "description": "Investigate and fix the three unit tests that are currently failing due to mock setup issues. Ensure that all external dependencies are correctly mocked and that the tests accurately reflect the intended behavior of the useTeamAuth composable.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Verify Comprehensive Test Coverage",
            "description": "Review the existing unit tests to confirm that all methods and scenarios of the useTeamAuth composable are adequately covered. Identify any gaps in test coverage and implement additional tests as necessary.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Document Test Cases and Results",
            "description": "Create detailed documentation for all unit tests, including descriptions of test cases, expected outcomes, and actual results. Highlight any areas where issues were identified and how they were resolved.",
            "status": "done"
          }
        ]
      },
      {
        "id": 30,
        "title": "Write Unit Tests for Supabase Edge Functions",
        "description": "Create comprehensive unit tests for all Edge Functions (create-team-and-owner, invite-member, accept-invite, start-impersonation, stop-impersonation, transfer-ownership) using TDD methodology. Test input validation, error handling, permission checks, and expected outputs with mocked Supabase clients.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          3,
          28
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Package Current Project as a Distributable Nuxt Module",
        "description": "Analyze the current project structure and package it as a Nuxt module following best practices.",
        "details": "1. Research Nuxt module packaging best practices, focusing on structure, configuration, and distribution.\n2. Examine the current codebase to identify components, utilities, and configurations that should be exposed as part of the module versus those that should remain internal.\n3. Define the module's entry points and ensure compatibility with both ESM and CJS.\n4. Plan and implement a build process that compiles the module for distribution, including bundling and minification.\n5. Set up npm/pnpm scripts for building, testing, and publishing the module.\n6. Ensure the package.json is correctly configured with metadata, dependencies, and peer dependencies.\n7. Document the module's API, installation instructions, and usage examples.\n8. Consider versioning strategy and semantic versioning for future updates.",
        "testStrategy": "1. Verify the module can be installed and used in a fresh Nuxt 3 project.\n2. Test the module's API to ensure all exposed functions and components work as expected.\n3. Run integration tests to confirm the module integrates smoothly with existing Nuxt 3 applications.\n4. Use tools like np and npm pack to simulate publishing and ensure the package is correctly structured.\n5. Validate the module's compatibility with both ESM and CJS environments.\n6. Review documentation for accuracy and completeness, ensuring it covers all aspects of installation and usage.",
        "status": "pending",
        "dependencies": [
          1,
          4,
          5
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Document and validate server endpoint handling",
            "description": "Ensure comprehensive understanding of how the module handles server-side endpoints and middleware for team authentication",
            "details": "1. Document all server endpoints used by the module (signup, signin, team management)\\n2. Verify middleware integration and how it affects consuming projects\\n3. Test server-side rendering compatibility\\n4. Validate API route generation and handling\\n5. Ensure proper error handling and response formatting",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 2,
            "title": "Create test project that uses the module",
            "description": "Set up a separate test project to validate the module works correctly when installed as a dependency",
            "details": "1. Create a fresh Nuxt 3 project in a separate directory\\n2. Install the packaged module as a dependency\\n3. Configure the module in the test project\\n4. Implement basic team authentication features using the module\\n5. Test all major module functionality (signup, signin, team management)\\n6. Validate that the module doesn't conflict with other Nuxt modules\\n7. Test development and production builds",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 3,
            "title": "Test Supabase integration with existing project",
            "description": "Validate how the module integrates with projects that already have Supabase configured",
            "details": "1. Set up a test project with existing Supabase configuration\\n2. Install and configure the team auth module\\n3. Verify that module doesn't conflict with existing Supabase setup\\n4. Test database schema migration and integration\\n5. Validate RLS policies work alongside existing policies\\n6. Ensure auth flows don't interfere with existing authentication\\n7. Document any configuration requirements or conflicts\\n8. Test edge cases where tables or policies might already exist",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 4,
            "title": "Test Supabase integration with fresh project",
            "description": "Validate how the module works with projects that don't have any existing Supabase configuration",
            "details": "1. Create a fresh Nuxt 3 project without Supabase\\n2. Install the team auth module\\n3. Test the module's ability to bootstrap Supabase configuration\\n4. Verify automatic database schema setup and migrations\\n5. Test the complete setup flow from scratch\\n6. Validate that all required dependencies are properly installed\\n7. Ensure the module provides clear setup instructions\\n8. Test both local development and production deployment scenarios\\n9. Document the complete setup process for new projects",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 5,
            "title": "Create comprehensive module documentation",
            "description": "Develop complete documentation for the module including API reference, setup guides, and examples",
            "details": "1. Create README.md with installation and quick start guide\\n2. Document module configuration options and environment variables\\n3. Create API reference for all exposed components, composables, and utilities\\n4. Write setup guides for both fresh and existing Supabase projects\\n5. Document database schema requirements and migrations\\n6. Create usage examples for common scenarios (signup, team management, etc.)\\n7. Document troubleshooting common issues\\n8. Create migration guide from standalone to module usage\\n9. Document TypeScript types and interfaces\\n10. Add JSDoc comments to all public APIs",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 36
          }
        ]
      },
      {
        "id": 37,
        "title": "Roadmap - Future Enhancements",
        "description": "Create a container task for tracking potential future enhancements and nice-to-have features post-MVP.",
        "details": "This task serves as a placeholder for collecting and organizing ideas for future enhancements that are not critical for the MVP but could significantly improve the product. These enhancements might include additional features, performance optimizations, UI/UX improvements, or integrations with other services. The task should be regularly updated with new ideas as they arise and prioritized based on user feedback and strategic goals. This task will not have direct implementation work but will guide future development efforts.",
        "testStrategy": "Verify that the task is used to collect and document potential enhancements. Ensure that each enhancement idea is clearly described, including its potential impact, estimated effort, and any dependencies. Regularly review and update the list to reflect current priorities and strategic direction.",
        "status": "pending",
        "dependencies": [
          11
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CLI Tool for Project Initialization and Migrations",
            "description": "Build the team-auth CLI tool for init and migrate commands with automatic Supabase integration",
            "status": "pending",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement CLI with commands:\n- team-auth init: Copy migrations to supabase/migrations/team-auth/, copy edge functions to supabase/functions/team-auth/, detect Supabase project linking, auto-run supabase db push, add package.json scripts\n- team-auth migrate: Apply new migrations in order, verify schema version compatibility\n\nFeatures:\n- Detect existing Supabase CLI installation and project linking\n- Version-aware migration system (patch/minor/major versioning policy)\n- Automatic file copying with proper directory structure\n- Integration with Supabase CLI commands\n- Clear user feedback and error messages\n- Commit reminders for CI/CD integration",
            "testStrategy": "CLI integration tests with mocked file system and Supabase CLI. Version compatibility tests. Error handling tests for missing dependencies."
          },
          {
            "id": 2,
            "title": "Add Internationalization and Accessibility Features",
            "description": "Implement i18n support with externalized strings and ensure WCAG 2.1 AA compliance across all components",
            "status": "pending",
            "dependencies": [
              5
            ],
            "details": "Internationalization:\n- Externalize all user-facing strings to JSON files\n- Default English locale with override mechanism\n- Support for custom locale JSON files\n- Integration with Nuxt i18n module\n- Pluralization support for dynamic content\n\nAccessibility:\n- WCAG 2.1 AA compliance across all components\n- Keyboard navigation support\n- Screen reader compatibility with proper ARIA labels\n- Focus management for modals and dropdowns\n- Color contrast validation\n- Alternative text for all images and icons\n- Semantic HTML structure",
            "testStrategy": "Accessibility audit with axe-core, keyboard navigation tests, screen reader tests with NVDA/JAWS, color contrast validation, i18n tests with multiple locales."
          },
          {
            "id": 3,
            "title": "Create Demo Application and Documentation",
            "description": "Build comprehensive demo application showcasing all features with complete documentation and integration guides",
            "status": "pending",
            "dependencies": [
              5,
              7,
              9
            ],
            "details": "Demo Application:\n- Complete Nuxt 3 app demonstrating all team-auth features\n- Example pages: sign-up, dashboard, team management, profile, admin panel\n- Integration examples with different UI frameworks\n- Performance optimization examples\n- Error handling demonstrations\n\nDocumentation:\n- Installation and setup guide\n- API reference for useTeamAuth composable\n- Component documentation with props/slots/events\n- Migration guide and versioning policy\n- Security best practices\n- Troubleshooting guide\n- Integration examples with popular Nuxt modules\n- Performance optimization tips",
            "testStrategy": "Documentation accuracy tests, demo app functionality tests, integration guide validation, performance benchmarks against ≤150ms P95 latency requirement."
          },
          {
            "id": 4,
            "title": "Add Multi-Factor Authentication Integration",
            "description": "Implement MFA toggle functionality with TOTP support and enforce MFA for super-admin operations",
            "status": "pending",
            "dependencies": [
              4,
              6
            ],
            "details": "MFA Implementation:\n- TOTP (Time-based One-Time Password) support using authenticator apps\n- MFA enrollment flow with QR code generation\n- MFA toggle in user profile settings\n- Mandatory MFA for super-admin role\n- MFA verification before impersonation start\n- Backup codes generation and validation\n- MFA recovery flow for lost devices\n- Integration with Supabase Auth MFA features\n- Graceful fallback for MFA failures\n- MFA status indicators in UI components",
            "testStrategy": "MFA enrollment tests, TOTP validation tests, backup code tests, super-admin MFA enforcement tests, recovery flow tests, integration tests with authenticator apps."
          },
          {
            "id": 5,
            "title": "Implement Performance Optimization and Caching",
            "description": "Add performance optimizations, caching strategies, and monitoring to meet the ≤150ms P95 latency requirement",
            "status": "pending",
            "dependencies": [
              4,
              5
            ],
            "details": "Performance Optimization:\n- Client-side caching for team data and user profiles\n- Optimistic updates for UI responsiveness\n- Lazy loading for non-critical components\n- Database query optimization with proper indexing\n- Edge Function response caching where appropriate\n- Bundle size optimization with tree shaking\n- Image optimization for avatars and assets\n- Connection pooling for database operations\n- CDN integration for static assets\n\nMonitoring:\n- Performance metrics collection\n- Latency monitoring for auth operations\n- Error rate tracking\n- User experience metrics\n- Database performance monitoring",
            "testStrategy": "Performance benchmarking against 150ms P95 target, load testing with concurrent users, cache effectiveness tests, bundle size analysis, database query performance tests."
          },
          {
            "id": 6,
            "title": "Set up GitHub Repository with gh CLI and Project Configuration",
            "description": "Initialize a GitHub repository for the nuxt-supabase-team-auth project using gh CLI with proper configuration, documentation, and repository settings.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Set up the GitHub repository infrastructure for the project:\n\n1. **Repository Creation with gh CLI:**\n   - Use `gh repo create nuxt-supabase-team-auth --public --clone` to create and clone repository\n   - Configure repository description: \"A Nuxt 3 module for team-based authentication with Supabase\"\n   - Set repository topics: nuxt, supabase, authentication, team-management, typescript\n\n2. **Repository Configuration:**\n   - Enable GitHub Pages for documentation hosting\n   - Configure branch protection rules for main branch\n   - Set up issue and PR templates in .github/ directory\n   - Configure repository settings for security and collaboration\n\n3. **Documentation Setup:**\n   - Create comprehensive README.md with project overview, installation, usage examples\n   - Include badges for build status, npm version, license\n   - Add getting started guide and API documentation structure\n   - Create CONTRIBUTING.md with development guidelines\n\n4. **License and Legal:**\n   - Add MIT license file using `gh repo edit --add-license mit`\n   - Create CODE_OF_CONDUCT.md for community guidelines\n   - Add SECURITY.md for vulnerability reporting\n\n5. **Initial Repository Structure:**\n   - Set up .gitignore for Node.js, Nuxt, and IDE files\n   - Configure .github/workflows/ directory for future CI/CD\n   - Add package.json validation and sync with repository metadata\n   - Create initial directory structure aligned with Nuxt 3 module standards\n\n6. **Repository Metadata:**\n   - Configure repository homepage URL\n   - Set up repository social preview image\n   - Add relevant keywords and description for discoverability",
            "testStrategy": "Verify repository setup completion:\n\n1. **Repository Verification:**\n   - Confirm repository exists and is publicly accessible on GitHub\n   - Verify repository description, topics, and metadata are correctly set\n   - Check that repository homepage and social preview are configured\n\n2. **Documentation Quality Check:**\n   - Validate README.md renders correctly with all sections and badges\n   - Ensure all links in documentation are functional\n   - Verify license file is properly recognized by GitHub\n   - Check that CONTRIBUTING.md and CODE_OF_CONDUCT.md are accessible\n\n3. **Repository Configuration Testing:**\n   - Test branch protection rules are active on main branch\n   - Verify issue and PR templates are available when creating new issues/PRs\n   - Confirm GitHub Pages is enabled and accessible\n   - Check repository settings match security and collaboration requirements\n\n4. **Local Development Setup:**\n   - Clone repository locally and verify all files are present\n   - Ensure .gitignore properly excludes intended files\n   - Validate package.json metadata matches repository information\n   - Test that repository structure aligns with Nuxt 3 module conventions\n\n5. **Integration Verification:**\n   - Confirm gh CLI commands work correctly with the repository\n   - Verify repository can be found through GitHub search with configured topics\n   - Test that repository is ready for future CI/CD pipeline integration"
          },
          {
            "id": 7,
            "title": "Implement End-to-End Testing with Playwright",
            "description": "Set up Playwright E2E testing framework for complete user journey testing including signup, team management, impersonation workflows, and cross-browser compatibility. Include test data seeding, cleanup, and CI/CD integration.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 37
          },
          {
            "id": 8,
            "title": "Implement Security Hardening and Audit Logging",
            "description": "Add comprehensive security measures, audit logging, and vulnerability prevention mechanisms",
            "status": "pending",
            "dependencies": [
              6,
              10
            ],
            "details": "Security Hardening:\n- JWT signature validation with custom claims verification\n- Rate limiting for sensitive operations (invites, role changes)\n- CSRF protection for state-changing operations\n- Input validation and sanitization\n- SQL injection prevention in custom queries\n- Secure token generation and hashing\n- Session fixation prevention\n- Privilege escalation detection and prevention\n\nAudit Logging:\n- Immutable audit trail for all team operations\n- 1-year retention policy for impersonation sessions\n- Comprehensive logging for role changes, invitations, deletions\n- Security event logging (failed auth, suspicious activity)\n- Log integrity verification\n- GDPR-compliant data handling",
            "testStrategy": "Security penetration testing, audit log integrity tests, privilege escalation prevention tests, rate limiting validation, input sanitization tests, session security tests."
          },
          {
            "id": 9,
            "title": "Create Comprehensive Test Suite and CI/CD Pipeline",
            "description": "Build complete testing infrastructure with unit, integration, and E2E tests achieving ≥90% coverage",
            "status": "pending",
            "dependencies": [
              11,
              12,
              13,
              14
            ],
            "details": "Test Suite:\n- Unit tests for all composables, components, and utilities (Jest/Vitest)\n- Integration tests for Supabase Edge Functions and database operations\n- E2E tests for complete user flows (Cypress/Playwright)\n- Component testing with Vue Test Utils\n- API testing for all endpoints\n- Security testing for auth flows and permissions\n- Performance testing for latency requirements\n- Accessibility testing with automated tools\n\nCI/CD Pipeline:\n- Automated testing on pull requests\n- Code coverage reporting with ≥90% target\n- Security scanning with dependency checks\n- Lighthouse performance and accessibility audits (≥90 a11y score)\n- Automated deployment to staging environment\n- Release automation with semantic versioning\n- Database migration testing\n- Cross-browser compatibility testing",
            "testStrategy": "Meta-testing: Validate test coverage accuracy, CI/CD pipeline reliability, test execution performance, flaky test detection and resolution."
          },
          {
            "id": 10,
            "title": "Write Integration Tests for Database Operations and RLS",
            "description": "Implement integration tests for database schema, RLS policies, and SQL helper functions using real Supabase test database. Test team-scoped data access, permission boundaries, and cross-user data isolation. Verify RLS policies block unauthorized access and allow proper team member access.",
            "status": "pending",
            "dependencies": [
              21,
              25,
              28
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Write Component Tests for Vue UI Components",
            "description": "Create unit and integration tests for all Vue components (AuthSignIn, AuthSignUpWithTeam, UserButton, ProfileForm, TeamMembersTable, TeamSettingsModal, SignedIn, SignedOut) using Vue Test Utils. Test component rendering, user interactions, prop handling, and integration with useTeamAuth composable.",
            "status": "pending",
            "dependencies": [
              5,
              29,
              28
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "Write End-to-End Tests for Complete User Flows",
            "description": "Implement E2E tests using Playwright covering complete user journeys: signup with team creation, invitation flow, team management, role changes, impersonation workflow, and session persistence across page reloads. Test both happy paths and error scenarios with real Supabase backend.",
            "status": "pending",
            "dependencies": [
              22,
              23,
              24,
              28
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 13,
            "title": "Write Security and Performance Tests",
            "description": "Create specialized tests for security vulnerabilities (SQL injection, privilege escalation, session hijacking) and performance benchmarks (≤150ms P95 latency requirement). Include load testing for Edge Functions and stress testing for concurrent impersonation sessions.",
            "status": "pending",
            "dependencies": [
              12,
              14,
              28
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 14,
            "title": "Write Tests for CLI Tool and Module Integration",
            "description": "Create tests for the CLI tool commands (init, migrate), module installation process, and integration with consuming Nuxt applications. Test schema migration workflows, Edge Function deployment, and module configuration in various project setups.",
            "status": "pending",
            "dependencies": [
              7,
              28
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 15,
            "title": "Complete Nuxt Module Packaging and Distribution Setup",
            "description": "Finalize the setup for distributing the project as a Nuxt module, including server API route handling, Supabase integration, and TypeScript exports.",
            "status": "pending",
            "dependencies": [
              1,
              3,
              4
            ],
            "details": "To complete the Nuxt module packaging and distribution setup, follow these steps: 1. Ensure the module is structured according to Nuxt 3 guidelines, building upon the initial setup from Task 1. 2. Implement server API route handling within the module, ensuring routes are correctly registered and accessible. 3. Develop strategies for integrating Supabase configuration, accommodating both projects with existing Supabase setups and those without. This includes handling environment variables securely and providing clear documentation for users. 4. Configure TypeScript exports to ensure compatibility and ease of use in consuming projects. 5. Test the module installation via npm in other projects, verifying that all functionalities, including Supabase integration and API routes, work seamlessly. 6. Update documentation to guide users through installation, configuration, and usage of the module.",
            "testStrategy": "1. Verify that the module can be installed in a fresh Nuxt 3 project via npm and that all functionalities work as expected. 2. Test server API routes to ensure they are correctly registered and accessible. 3. Validate Supabase integration by setting up a test project with and without existing Supabase configurations, ensuring environment variables are managed correctly. 4. Check TypeScript exports for correctness and usability in consuming projects. 5. Conduct end-to-end tests in a sample project to ensure the module's features integrate smoothly with other Nuxt components and plugins. 6. Review and test the documentation by following the installation and configuration steps to ensure clarity and completeness."
          }
        ]
      },
      {
        "id": 38,
        "title": "Develop Unit Tests for Middleware Functions",
        "description": "Create comprehensive unit tests for middleware functions focusing on isolated logic, edge cases, and specific route protection scenarios.",
        "status": "pending",
        "dependencies": [
          24,
          4
        ],
        "priority": "medium",
        "details": "Develop unit tests for middleware functions to ensure isolated logic is thoroughly tested without relying on mocked implementations. Focus on edge cases such as session expiration, network errors, malformed parameters, role hierarchy, and complex middleware combinations. Additionally, include tests for specific route protection scenarios: protected route middleware behavior, admin route middleware with role hierarchy, team-specific route validation, owner-only route protection, impersonation route blocking (admin routes blocked during impersonation), complex nested route requirements, optional team parameter handling, and concurrent middleware execution testing. These tests should complement existing integration tests by providing detailed coverage of unit-level behavior. Use a testing framework like Jest to write and execute these tests, ensuring each middleware function is tested in isolation. Consider using dependency injection or similar techniques to isolate middleware logic from external dependencies. Ensure that tests are written to cover all possible edge cases and scenarios, particularly those that are not covered by integration tests.",
        "testStrategy": "1. Use Jest to write unit tests for each middleware function. \n2. Test middleware functions in isolation, ensuring no external dependencies are mocked. \n3. Cover edge cases such as session expiration, network errors, malformed parameters, role hierarchy, and complex middleware combinations. \n4. Include tests for specific route protection scenarios: protected route middleware behavior, admin route middleware with role hierarchy, team-specific route validation, owner-only route protection, impersonation route blocking, complex nested route requirements, optional team parameter handling, and concurrent middleware execution testing. \n5. Verify that each test accurately reflects the middleware's expected behavior in these scenarios. \n6. Run the tests and ensure all pass successfully. \n7. Review test coverage reports to ensure comprehensive coverage of middleware logic.",
        "subtasks": [
          {
            "id": 39,
            "title": "Implement unit tests for protected route middleware behavior",
            "description": "Develop unit tests to verify the behavior of middleware protecting specific routes, ensuring unauthorized access is blocked.",
            "status": "pending"
          },
          {
            "id": 40,
            "title": "Implement unit tests for admin route middleware with role hierarchy",
            "description": "Create unit tests to ensure that admin routes are protected based on role hierarchy, allowing only authorized roles to access.",
            "status": "pending"
          },
          {
            "id": 41,
            "title": "Implement unit tests for team-specific route validation",
            "description": "Write unit tests to validate middleware behavior for routes specific to team contexts, ensuring correct team access.",
            "status": "pending"
          },
          {
            "id": 42,
            "title": "Implement unit tests for owner-only route protection",
            "description": "Develop unit tests to verify that routes restricted to owners are correctly protected by middleware.",
            "status": "pending"
          },
          {
            "id": 43,
            "title": "Implement unit tests for impersonation route blocking",
            "description": "Create unit tests to ensure that admin routes are blocked during impersonation sessions.",
            "status": "pending"
          },
          {
            "id": 44,
            "title": "Implement unit tests for complex nested route requirements",
            "description": "Write unit tests to verify middleware behavior for routes with complex nested requirements.",
            "status": "pending"
          },
          {
            "id": 45,
            "title": "Implement unit tests for optional team parameter handling",
            "description": "Develop unit tests to ensure middleware correctly handles optional team parameters in routes.",
            "status": "pending"
          },
          {
            "id": 46,
            "title": "Implement unit tests for concurrent middleware execution",
            "description": "Create unit tests to verify the behavior of middleware when executed concurrently.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 39,
        "title": "Document Simplified Invitation Approach Using Supabase",
        "description": "Update documentation and code comments to reflect the current invitation approach using Supabase's auth.users table and auth.admin.inviteUserByEmail() method.",
        "details": "1. Review the current implementation of the invitation system that uses Supabase's auth.users table instead of custom tracking tables.\\n2. Update the documentation to clearly describe the use of auth.admin.inviteUserByEmail() with team metadata in options.\\n3. Document how admin tracking is performed by querying the auth.users table, specifically focusing on the invited_at, email_confirmed_at, and raw_user_meta_data fields.\\n4. Ensure that all relevant code comments are updated to reflect these changes, providing clear guidance for future developers.\\n5. Coordinate with the team to ensure that the documentation aligns with the current system architecture and practices.",
        "testStrategy": "1. Verify that the updated documentation accurately reflects the current implementation of the invitation system.\\n2. Check that all code comments are clear and provide sufficient context for developers.\\n3. Ensure that the documentation includes examples of how to use auth.admin.inviteUserByEmail() and how to query auth.users for tracking purposes.\\n4. Conduct a peer review with team members to confirm the clarity and accuracy of the documentation updates.",
        "status": "pending",
        "dependencies": [
          3,
          17
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-18T17:53:26.166Z",
      "updated": "2025-06-21T13:47:43.311Z",
      "description": "Tasks for master context"
    }
  }
}