{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Nuxt 3 Module Structure and Package Configuration",
        "description": "Set up the foundational Nuxt 3 module structure with proper TypeScript configuration, package.json setup, and CLI tooling for distribution",
        "details": "Create module structure following Nuxt 3 module guidelines:\n- Initialize package.json with @yourco/team-auth name\n- Set up module.ts with defineNuxtModule\n- Configure TypeScript with proper types for Nuxt 3\n- Create CLI entry point for team-auth init/migrate commands\n- Set up build configuration for both module and CLI distribution\n- Configure exports for ESM/CJS compatibility\n- Add peer dependencies: nuxt ^3.0.0, @supabase/supabase-js, @nuxt/ui",
        "testStrategy": "Unit tests for module registration, CLI command parsing, and package structure validation. Integration test for module loading in Nuxt 3 app.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize package.json with proper configuration",
            "description": "Create and configure the package.json file with appropriate metadata, dependencies, and scripts for the Nuxt 3 module.",
            "dependencies": [],
            "details": "Create package.json with name '@yourco/team-auth', set version to '0.1.0', add description, set type to 'module', configure main/module/types fields, add peer dependencies (nuxt ^3.0.0, @supabase/supabase-js, @nuxt/ui), set up dev dependencies (typescript, nuxt, unbuild, etc.), and create basic npm scripts for development, build, and publishing.",
            "status": "done",
            "testStrategy": "Verify package.json structure using npm's package validation and ensure all required fields are present."
          },
          {
            "id": 2,
            "title": "Set up TypeScript configuration",
            "description": "Configure TypeScript for the Nuxt 3 module with proper type definitions and compiler options.",
            "dependencies": [
              1
            ],
            "details": "Create tsconfig.json with appropriate compiler options (target: ESNext, module: ESNext, moduleResolution: bundler, etc.), include necessary type definitions for Nuxt 3, set up paths for module resolution, configure strict type checking, and ensure proper declaration file generation for the module's public API.",
            "status": "done",
            "testStrategy": "Run TypeScript compiler in check mode to verify configuration is valid and types are properly resolved."
          },
          {
            "id": 3,
            "title": "Create module.ts with defineNuxtModule implementation",
            "description": "Implement the core module.ts file using defineNuxtModule to register the auth module with Nuxt 3.",
            "dependencies": [
              2
            ],
            "details": "Create src/module.ts using defineNuxtModule with proper meta information, implement setup function that adds runtime directory, register composables, add module options interface with typed configuration, set default options, and implement basic hooks for module initialization. Ensure proper TypeScript typing throughout the implementation.",
            "status": "done",
            "testStrategy": "Create a minimal Nuxt 3 test project and verify the module can be imported and initialized without errors."
          },
          {
            "id": 4,
            "title": "Set up build configuration for module distribution",
            "description": "Configure the build system to properly bundle and distribute the Nuxt module for both ESM and CJS compatibility.",
            "dependencies": [
              3
            ],
            "details": "Create build.config.ts using unbuild or similar tool, configure entry points for the module, set up external dependencies, configure output formats (esm, cjs), set up proper exports in package.json for dual package hazard avoidance, configure TypeScript declaration file generation, and ensure source maps are generated for debugging.",
            "status": "done",
            "testStrategy": "Run the build process and verify output files are generated correctly with proper module formats and type declarations."
          },
          {
            "id": 5,
            "title": "Implement CLI entry point for module commands",
            "description": "Create a CLI interface for the module with init and migrate commands to help users set up and maintain the auth system.",
            "dependencies": [
              4
            ],
            "details": "Create src/cli.ts using a CLI framework like commander or yargs, implement 'team-auth init' command to scaffold initial auth configuration, add 'team-auth migrate' command for schema updates, configure bin field in package.json to expose CLI commands, ensure proper error handling and user feedback, and add help text for all commands. Make CLI executable with proper shebang.",
            "status": "done",
            "testStrategy": "Test CLI commands in isolation with mock filesystem to verify they perform expected operations without side effects."
          }
        ]
      },
      {
        "id": 2,
        "title": "Design and Implement Database Schema with RLS Policies",
        "description": "Create PostgreSQL schema for teams, team_members, invites, and impersonation_sessions tables with comprehensive Row Level Security policies",
        "details": "Implement the exact schema from the ERD:\n- teams table: id (uuid), name (text), address (text), vat_number (text), created_at (timestamp)\n- team_members table: team_id (uuid FK), user_id (uuid FK), role (enum: owner|admin|member|super_admin), joined_at (timestamp)\n- invites table: id (uuid), team_id (uuid FK), email (text), token_hash (text), expires_at (timestamp), status (enum: pending|accepted|revoked)\n- impersonation_sessions table: id (uuid), admin_user_id (uuid FK), target_user_id (uuid FK), started_at (timestamp), ended_at (timestamp), reason (text)\n\nRLS Policies:\n- team_members: SELECT for members, INSERT/DELETE for admins/owners within team\n- teams: UPDATE for owners only, SELECT for all team members\n- invites: Full CRUD for admins/owners within team, SELECT for invitee by token\n- impersonation_sessions: Service-role only for INSERT/UPDATE, SELECT for super-admin own sessions",
        "testStrategy": "Database tests for schema creation, RLS policy enforcement, foreign key constraints, and enum validation. Test each policy with different user roles.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Base Database Tables and Enums",
            "description": "Set up the foundational database schema by creating the required tables and enum types according to the ERD specifications.",
            "dependencies": [],
            "details": "Create the following PostgreSQL enum types: 'team_role' (owner, admin, member, super_admin) and 'invite_status' (pending, accepted, revoked). Then create the four tables with proper constraints: teams (with primary key id), team_members (with composite primary key of team_id and user_id), invites (with primary key id), and impersonation_sessions (with primary key id). Ensure all foreign key relationships are properly established.",
            "status": "done",
            "testStrategy": "Verify table creation with \\dt command in psql. Test enum types with sample inserts and validate constraints with intentional violations to ensure they're enforced."
          },
          {
            "id": 2,
            "title": "Implement RLS Policies for Teams Table",
            "description": "Create Row Level Security policies for the teams table to enforce proper access control.",
            "dependencies": [
              1
            ],
            "details": "Enable RLS on the teams table with 'ALTER TABLE teams ENABLE ROW LEVEL SECURITY'. Create policies that allow: 1) SELECT access for all team members (by joining with team_members table), 2) UPDATE access only for team owners, 3) INSERT/DELETE access for service role only. Ensure the policies use the current user context via auth.uid() for user identification.",
            "status": "done",
            "testStrategy": "Test each policy by attempting operations as different user roles. Verify owners can update team details while admins and members cannot. Confirm all team members can view their teams."
          },
          {
            "id": 3,
            "title": "Implement RLS Policies for Team Members Table",
            "description": "Create Row Level Security policies for the team_members table to control membership management.",
            "dependencies": [
              1
            ],
            "details": "Enable RLS on the team_members table. Create policies that allow: 1) SELECT access for members of the same team, 2) INSERT/DELETE access for admins and owners within their team, 3) Full access for super_admins across all teams. Use auth.uid() to identify the current user and join with team_members to determine their role within each team.",
            "status": "done",
            "testStrategy": "Test member visibility within teams. Verify admins can add/remove members while regular members cannot. Confirm super_admins have full access across all teams."
          },
          {
            "id": 4,
            "title": "Implement RLS Policies for Invites Table",
            "description": "Create Row Level Security policies for the invites table to manage team invitation access.",
            "dependencies": [
              1
            ],
            "details": "Enable RLS on the invites table. Create policies that allow: 1) Full CRUD operations for admins and owners within their team, 2) SELECT access for invitees based on their email and token, 3) No access for regular team members. Include a policy for service role access for system-level operations. Ensure proper joins with team_members to verify admin/owner status.",
            "status": "done",
            "testStrategy": "Test invite creation as admins and owners. Verify regular members cannot create or view invites. Test that users can view invites addressed to their email with the correct token."
          },
          {
            "id": 5,
            "title": "Implement RLS Policies for Impersonation Sessions Table",
            "description": "Create Row Level Security policies for the impersonation_sessions table to enforce strict access control for this sensitive feature.",
            "dependencies": [
              1
            ],
            "details": "Enable RLS on the impersonation_sessions table. Create policies that allow: 1) INSERT/UPDATE operations only for the service role, 2) SELECT access for super_admins but only for sessions they initiated (where admin_user_id = auth.uid()), 3) No direct access for regular users, admins, or owners. Add appropriate comments explaining the security implications of these policies.",
            "status": "done",
            "testStrategy": "Test that only the service role can create impersonation sessions. Verify super_admins can only view their own sessions. Confirm regular users, admins, and owners have no access to this table."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement Supabase Edge Functions for Core Team Operations",
        "description": "Create all required Supabase Edge Functions for team creation, invitations, role management, and impersonation with proper security",
        "details": "Implement Edge Functions in TypeScript:\n- create_team_and_owner(): Transaction to create team + add owner + issue JWT with team claims\n- accept_invite(): Validate token hash, add user to team, mark invite accepted\n- transfer_ownership(): Change owner role, demote previous owner to admin\n- start_impersonation(): Verify super-admin + MFA, mint 30-min JWT with act_as claims, log session\n- stop_impersonation(): End session, revoke JWT, update ended_at timestamp\n- get_user_emails(): Security-definer function for super-admin email access\n- get_user_email_by_id(): Single email lookup for super-admin\n- admin_login(): Generate magic link + immediate OTP verification for super-admin session restore\n\nImplement email retrieval strategy cascade with single selected method for reliability. Include proper error handling and JWT claim validation.",
        "testStrategy": "Unit tests for each function with mocked Supabase client. Integration tests with real database. Security tests for privilege escalation prevention and MFA enforcement.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Team Creation and Invitation Edge Functions",
            "description": "Create the Edge Functions for team creation and invitation management, including create_team_and_owner() and accept_invite() functions.",
            "dependencies": [],
            "details": "For create_team_and_owner(): Implement a transaction that creates a new team record, adds the creator as owner, and issues a JWT with appropriate team claims. For accept_invite(): Implement token validation logic, add the user to the team with specified role, and mark the invitation as accepted in the database. Both functions should include proper error handling and input validation.",
            "status": "done",
            "testStrategy": "Test with valid and invalid inputs, verify database state after operations, and check JWT claims for correctness. Test edge cases like duplicate team names and expired invitation tokens."
          },
          {
            "id": 2,
            "title": "Implement Role Management Edge Functions",
            "description": "Create the Edge Functions for team role management, specifically the transfer_ownership() function to change team ownership.",
            "dependencies": [],
            "details": "Implement transfer_ownership() to securely change the team owner role. The function should verify the current owner's identity, promote the target user to owner, and demote the previous owner to admin role. Include transaction handling to ensure atomicity of the role changes. Add proper authorization checks to ensure only the current owner can transfer ownership.",
            "status": "done",
            "testStrategy": "Test successful ownership transfers, verify role changes in database, test authorization failures when non-owners attempt transfers, and verify error handling for invalid user IDs."
          },
          {
            "id": 3,
            "title": "Implement User Impersonation Edge Functions",
            "description": "Create the Edge Functions for user impersonation, including start_impersonation() and stop_impersonation() functions.",
            "dependencies": [],
            "details": "For start_impersonation(): Implement verification of super-admin status and MFA completion, then mint a time-limited JWT (30 minutes) with act_as claims, and log the impersonation session. For stop_impersonation(): Implement logic to end the session, revoke the JWT, and update the ended_at timestamp in the session log. Both functions should include comprehensive security checks and audit logging.",
            "status": "done",
            "testStrategy": "Test impersonation lifecycle with valid super-admin credentials, verify JWT claims and expiration, test MFA requirement enforcement, and verify proper session logging and termination."
          },
          {
            "id": 4,
            "title": "Implement Email Retrieval Edge Functions",
            "description": "Create the Edge Functions for email retrieval, including get_user_emails() and get_user_email_by_id() functions with proper security controls.",
            "dependencies": [
              3
            ],
            "details": "Implement get_user_emails() as a security-definer function that allows super-admins to access user emails in bulk. Implement get_user_email_by_id() for single email lookup by super-admins. Both functions should implement the email retrieval strategy cascade for reliability. Add strict authorization checks to ensure only super-admins can access these functions, and implement rate limiting to prevent abuse.",
            "status": "done",
            "testStrategy": "Test authorization controls to verify only super-admins can access emails, test the email retrieval cascade strategy with various scenarios (primary method failure, fallback success), and verify rate limiting effectiveness."
          },
          {
            "id": 5,
            "title": "Implement Admin Authentication and Error Handling",
            "description": "Create the admin_login() Edge Function and implement comprehensive error handling across all functions.",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement admin_login() to generate magic links with immediate OTP verification for super-admin session restoration. Add standardized error handling across all Edge Functions with appropriate HTTP status codes and error messages. Implement JWT claim validation helpers that can be reused across functions. Add logging for security events and errors to facilitate debugging and audit trails.",
            "status": "done",
            "testStrategy": "Test admin login flow with valid and invalid credentials, verify OTP verification works correctly, test error handling with various error conditions across all functions, and verify logs contain appropriate information for debugging and auditing."
          }
        ]
      },
      {
        "id": 4,
        "title": "Create Core Nuxt Composable useTeamAuth with Full API",
        "description": "Implement the main useTeamAuth() composable providing reactive state management, session persistence, dual-session management for impersonation, and state restoration on page reload.",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "high",
        "details": "Create composable with TypeScript interface:\n- Reactive state: currentUser, currentTeam, currentRole, isImpersonating, impersonationExpiresAt\n- Auth methods: signUpWithTeam, signIn, signOut\n- Team management: inviteMember, revokeInvite, resendInvite, promote, demote, transferOwnership\n- Profile: updateProfile, renameTeam, deleteTeam\n- Impersonation: startImpersonation, stopImpersonation\n\nIntegrate with Supabase client, handle JWT claims parsing, implement reactive updates on auth state changes. Include proper error handling with the defined error codes (TEAM_EXISTS, INVITE_EXPIRED, etc.). Implement defensive token storage across four tiers for impersonation sessions.\n\nEnsure session persistence using localStorage or sessionStorage to maintain user state across page reloads. Implement dual-session management to handle both the original user session and the impersonation session concurrently. Restore state appropriately on page reload to maintain a seamless user experience.",
        "testStrategy": "Unit tests for all composable methods, reactive state updates, session persistence, dual-session management, and error handling. Integration tests with Supabase Edge Functions. E2E tests for complete user flows, including state restoration on page reload.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Core State and Type Definitions",
            "description": "Create the foundation for useTeamAuth composable by defining TypeScript interfaces, reactive state, and initial setup with Supabase client.",
            "dependencies": [],
            "details": "1. Define TypeScript interfaces for all state objects (User, Team, Role, etc.)\n2. Create reactive state using Vue's ref/reactive for currentUser, currentTeam, currentRole, isImpersonating, impersonationExpiresAt\n3. Set up Supabase client integration\n4. Implement JWT claims parsing utility\n5. Create the basic composable structure with state initialization\n6. Add state reset functionality for sign-out",
            "status": "done",
            "testStrategy": "Unit test the state initialization, reset functionality, and JWT parsing utility."
          },
          {
            "id": 2,
            "title": "Implement Authentication Methods",
            "description": "Add core authentication methods to the composable: signUpWithTeam, signIn, and signOut with proper error handling.",
            "dependencies": [],
            "details": "1. Implement signUpWithTeam method that creates both user and team records\n2. Implement signIn method with email/password authentication\n3. Implement signOut method that clears state and Supabase session\n4. Add proper error handling with defined error codes (TEAM_EXISTS, etc.)\n5. Ensure reactive state updates after auth operations\n6. Implement auth state change listener to keep state in sync",
            "status": "done",
            "testStrategy": "Test each auth method with mock Supabase responses, verify error handling for various scenarios."
          },
          {
            "id": 3,
            "title": "Implement Team Management Methods",
            "description": "Add team management functionality: inviteMember, revokeInvite, resendInvite, promote, demote, and transferOwnership.",
            "dependencies": [],
            "details": "1. Implement inviteMember with email validation and role specification\n2. Add revokeInvite method to cancel pending invitations\n3. Implement resendInvite for expired invitations\n4. Create promote/demote methods for changing member roles\n5. Implement transferOwnership with confirmation checks\n6. Add proper permission validation for each operation\n7. Ensure reactive state updates after team changes",
            "status": "done",
            "testStrategy": "Test each team management method with various permission scenarios, verify state updates."
          },
          {
            "id": 4,
            "title": "Implement Profile and Team Settings Methods",
            "description": "Add methods for managing user profile and team settings: updateProfile, renameTeam, and deleteTeam.",
            "dependencies": [],
            "details": "1. Implement updateProfile method for changing user details\n2. Add renameTeam method with validation\n3. Implement deleteTeam with proper confirmation and cleanup\n4. Add permission checks for team operations\n5. Ensure reactive state updates after profile/team changes\n6. Implement proper error handling for each operation",
            "status": "done",
            "testStrategy": "Test each method with various scenarios including permission errors, validation failures."
          },
          {
            "id": 5,
            "title": "Implement Impersonation System",
            "description": "Add user impersonation functionality with multi-tiered token storage: startImpersonation and stopImpersonation.",
            "dependencies": [
              4
            ],
            "details": "1. Implement four-tier token storage system for impersonation sessions\n2. Create startImpersonation method with proper permission checks\n3. Add stopImpersonation method to revert to original user\n4. Implement expiration handling for impersonation sessions\n5. Add reactive state updates for isImpersonating and impersonationExpiresAt\n6. Ensure proper cleanup of tokens when impersonation ends\n7. Add security measures to prevent privilege escalation",
            "status": "done",
            "testStrategy": "Test impersonation lifecycle, token storage, expiration handling, and security constraints."
          },
          {
            "id": 6,
            "title": "Implement Session Persistence and State Restoration",
            "description": "Ensure session persistence using localStorage/sessionStorage and implement state restoration on page reload.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "1. Implement session persistence by storing relevant state in localStorage or sessionStorage\n2. Restore state from storage on page reload to maintain user session\n3. Handle synchronization between reactive state and stored session data\n4. Ensure security measures are in place to protect stored session data\n5. Test session persistence and state restoration across various scenarios",
            "status": "done",
            "testStrategy": "Test session persistence and state restoration functionality, including edge cases such as manual clearing of storage or session expiration."
          },
          {
            "id": 7,
            "title": "Implement Dual-Session Management for Impersonation",
            "description": "Manage concurrent sessions for both the original user and the impersonated user during impersonation.",
            "dependencies": [
              5,
              6
            ],
            "details": "1. Implement mechanisms to maintain both original and impersonation sessions concurrently\n2. Ensure seamless switching between sessions without data loss\n3. Handle session expiration and cleanup for both sessions appropriately\n4. Implement security measures to prevent unauthorized access to either session\n5. Test dual-session management across various impersonation scenarios",
            "status": "done",
            "testStrategy": "Test dual-session management functionality, including session switching, expiration handling, and security constraints."
          }
        ]
      },
      {
        "id": 5,
        "title": "Build Vue 3 UI Components Using Nuxt UI Primitives",
        "description": "Create all required Vue 3 components using only Nuxt UI open-source primitives as specified in the component mapping.",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "medium",
        "details": "Implement components using specified Nuxt UI primitives:\n- <AuthSignIn> & <AuthSignUpWithTeam>: Use UCard, UFormField, UInput, UButton\n- <UserButton>: Use UAvatar, UDropdownMenu for user menu\n- <ProfileForm>: Use UCard, UFormField, UInput, UButton for profile editing\n- <TeamMembersTable>: Use UTable, UBadge for role display\n- <TeamSettingsModal>: Use UModal, UFormField, UInput, UButton\n- <SignedIn> & <SignedOut>: Thin wrappers with v-if using isSignedIn from useTeamAuth\n\nEnsure WCAG 2.1 AA compliance, keyboard navigation, screen reader support. Expose slots and props for customization. Include impersonation banner component with countdown timer.",
        "testStrategy": "Component tests with Vue Test Utils, accessibility tests with @vue/test-utils and axe-core, visual regression tests, keyboard navigation tests.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Authentication Components",
            "description": "Create the <AuthSignIn> and <AuthSignUpWithTeam> components using Nuxt UI primitives for user authentication flows.",
            "dependencies": [],
            "details": "Use UCard as the container for both components. Implement form fields with UFormField and UInput for username/email, password, and team name (for signup). Add validation with appropriate error messages. Use UButton for submit actions with loading states. Ensure both components emit appropriate events (success, error) and integrate with the useTeamAuth composable. Include 'forgot password' link in the sign-in component. Ensure tab order is logical for keyboard navigation.",
            "status": "done",
            "testStrategy": "Test with various input combinations, validation errors, and success states. Verify ARIA attributes and keyboard navigation. Test screen reader announcements for form errors."
          },
          {
            "id": 2,
            "title": "Create User Profile Components",
            "description": "Implement the <UserButton> dropdown and <ProfileForm> components for user profile management.",
            "dependencies": [],
            "details": "For <UserButton>: Use UAvatar to display user profile image with fallback to initials. Implement UDropdownMenu with menu items for profile, settings, team management, and logout. For <ProfileForm>: Create a form using UCard, UFormField, and UInput for name, email, and profile image upload. Add validation and error handling. Use UButton for save/cancel actions with appropriate loading states. Both components should use data from useTeamAuth composable. Ensure proper focus management when opening/closing dropdowns.\n<info added on 2025-06-16T09:39:52.163Z>\n**UserButton Component:**\n- Created with UAvatar and UDropdown primitives\n- Role-based dropdown menu (different items for member/admin/super_admin)\n- Integrated with useTeamAuth composable (currentUser, currentRole, signOut)\n- Avatar with fallback to user initials\n- Proper event emission for profile/teamSettings/impersonation actions\n- Accessibility attributes and keyboard navigation support\n\n**ProfileForm Component:**\n- Created with UCard, UFormField, UInput, UButton primitives\n- Complete profile editing: name, email (readonly), avatar upload, password change\n- MFA toggle functionality with UToggle\n- Form validation using Valibot schema\n- File upload for avatar with 2MB size limit and preview\n- Change detection and form reset functionality\n- Integration with useTeamAuth.updateProfile method\n- Loading states and error/success messaging\n\n**Playground Testing:**\n- Both components added to playground and working\n- Proper Nuxt UI v3 styling matching existing components\n- All interactive elements functioning correctly\n- ClientOnly wrapper with loading fallbacks\n\nBoth components are production-ready and follow all PRD requirements (FR-5, FR-6). Ready to proceed with Team Management Components (subtask 5.3).\n</info added on 2025-06-16T09:39:52.163Z>",
            "status": "done",
            "testStrategy": "Test dropdown opening/closing, menu item selection, and form submission flows. Verify form validation and error states. Test keyboard navigation through dropdown menu items.",
            "subtasks": [
              {
                "id": 6,
                "title": "Test User Profile Components in Playground",
                "description": "Integrate and test the <UserButton> and <ProfileForm> components within the Nuxt UI v3 playground environment to ensure proper styling and functionality.",
                "dependencies": [],
                "details": "Add the <UserButton> and <ProfileForm> components to the playground. Verify that they render correctly with Nuxt UI styling. Test all interactive elements for proper behavior, including dropdown interactions and form submissions. Ensure that all components are responsive and accessible.",
                "status": "pending",
                "testStrategy": "Manual testing within the playground environment to verify component rendering, styling, and functionality. Automated tests for accessibility and responsiveness."
              }
            ]
          },
          {
            "id": 3,
            "title": "Develop Team Management Components",
            "description": "Build the <TeamMembersTable> and <TeamSettingsModal> components for team administration.",
            "dependencies": [],
            "details": "For <TeamMembersTable>: Implement UTable with columns for user details, role (using UBadge with appropriate colors), and actions. Include pagination, sorting, and filtering capabilities. Add row actions for role changes and member removal. For <TeamSettingsModal>: Create a modal using UModal with tabs for general settings, billing, and permissions. Use UFormField and UInput for form fields. Implement save/cancel actions with UButton. Ensure proper focus trapping within the modal and restore focus on close.",
            "status": "done",
            "testStrategy": "Test table sorting, filtering, and pagination. Verify role changes and member removal flows. Test modal opening/closing, tab switching, and form submission. Verify focus management and keyboard navigation within the modal.",
            "subtasks": [
              {
                "id": 7,
                "title": "Test Team Management Components in Playground",
                "description": "Integrate and test the <TeamMembersTable> and <TeamSettingsModal> components within the Nuxt UI v3 playground environment to ensure proper styling and functionality.",
                "dependencies": [],
                "details": "Add the <TeamMembersTable> and <TeamSettingsModal> components to the playground. Verify that they render correctly with Nuxt UI styling. Test all interactive elements for proper behavior, including table interactions and modal dialogs. Ensure that all components are responsive and accessible.",
                "status": "pending",
                "testStrategy": "Manual testing within the playground environment to verify component rendering, styling, and functionality. Automated tests for accessibility and responsiveness."
              }
            ]
          },
          {
            "id": 4,
            "title": "Implement Authentication State Components",
            "description": "Create the <SignedIn> and <SignedOut> wrapper components and the impersonation banner with countdown timer.",
            "dependencies": [],
            "details": "For <SignedIn> and <SignedOut>: Create thin wrapper components that conditionally render their slots based on authentication state from useTeamAuth. For the impersonation banner: Create a fixed position banner that appears when a user is being impersonated. Include user details, a countdown timer showing remaining session time, and an 'End Session' button. Use UButton and implement a reactive countdown timer. Ensure the banner is announced to screen readers appropriately.\n<info added on 2025-06-18T17:57:25.008Z>\nCompleted the implementation of `<SignedIn>` and `<SignedOut>` components. These components are thin wrappers that conditionally render their slot content based on the `currentUser` from the `useTeamAuth` composable. They are available via auto-import and have been tested in the playground. The impersonation banner will be addressed separately in Task 6.\n</info added on 2025-06-18T17:57:25.008Z>",
            "status": "done",
            "testStrategy": "Test conditional rendering based on authentication state changes. Verify the countdown timer updates correctly and ends session at zero. Test keyboard accessibility of the impersonation banner and screen reader announcements.",
            "subtasks": [
              {
                "id": 8,
                "title": "Test Authentication State Components in Playground",
                "description": "Integrate and test the <SignedIn>, <SignedOut>, and impersonation banner components within the Nuxt UI v3 playground environment to ensure proper styling and functionality.",
                "dependencies": [],
                "details": "Add the <SignedIn>, <SignedOut>, and impersonation banner components to the playground. Verify that they render correctly with Nuxt UI styling. Test all interactive elements for proper behavior, including conditional rendering and countdown timer functionality. Ensure that all components are responsive and accessible.",
                "status": "pending",
                "testStrategy": "Manual testing within the playground environment to verify component rendering, styling, and functionality. Automated tests for accessibility and responsiveness."
              }
            ]
          },
          {
            "id": 5,
            "title": "Ensure Accessibility and Component Customization",
            "description": "Review and enhance all components for WCAG 2.1 AA compliance and implement customization options through props and slots.",
            "dependencies": [],
            "details": "Audit all components for accessibility issues: ensure proper contrast ratios, keyboard navigation, focus indicators, and ARIA attributes. Test with screen readers. For customization: Add props for theming (colors, sizes, variants) to all components. Implement named slots for content customization (e.g., custom header/footer in cards, custom cell rendering in tables). Document all available props and slots. Create a consistent API across components. Ensure responsive behavior on all screen sizes.",
            "status": "done",
            "testStrategy": "Run automated accessibility tests (e.g., axe-core). Perform manual testing with keyboard-only navigation and screen readers. Test customization options by creating variant examples of each component with different props and slot content.",
            "subtasks": [
              {
                "id": 9,
                "title": "Test Component Accessibility and Customization in Playground",
                "description": "Integrate and test all components within the Nuxt UI v3 playground environment to ensure accessibility compliance and verify customization options.",
                "dependencies": [],
                "details": "Add all components to the playground. Verify that they meet WCAG 2.1 AA compliance standards. Test customization options through props and slots to ensure flexibility and consistency. Ensure that all components are responsive and accessible.",
                "status": "pending",
                "testStrategy": "Manual testing within the playground environment to verify accessibility compliance and customization options. Automated tests for accessibility and responsiveness."
              }
            ]
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Impersonation System with Security Controls",
        "description": "Build complete impersonation functionality with JWT-based session management, MFA enforcement, and audit logging",
        "details": "Implement Pattern A (Short-Lived JWT):\n- 30-minute JWT sessions with act_as claims\n- MFA re-prompt for super-admin before impersonation start\n- Session storage in Nuxt with automatic reload on context switch\n- Impersonation banner component with countdown and stop button\n- Auto-expiry handling with graceful fallback to admin context\n- Complete audit trail in impersonation_sessions table\n- Block admin routes when act_as=true to prevent privilege blending\n- Defensive token storage across server-verified, client-verified, storage restore, and manual tiers",
        "testStrategy": "Security tests for MFA enforcement, privilege separation, session expiry. Audit tests for complete logging. Integration tests for session management and context switching.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement JWT Token Generation with act_as Claims",
            "description": "Create the backend functionality to generate short-lived JWT tokens with act_as claims for impersonation sessions",
            "dependencies": [],
            "details": "Modify the authentication service to include act_as claims in JWT tokens. Implement token generation with 30-minute expiration. Create endpoints for starting impersonation that validates super-admin permissions and enforces MFA verification before generating the impersonation token. Ensure the token includes the impersonated user's ID, the admin's original ID, and appropriate scope limitations.",
            "status": "done",
            "testStrategy": "Unit test token generation with various user combinations. Integration test the MFA verification flow. Verify token expiration works correctly."
          },
          {
            "id": 2,
            "title": "Develop Session Management for Impersonation Context",
            "description": "Implement client-side session management to handle impersonation tokens, context switching, and automatic reload",
            "dependencies": [
              1
            ],
            "details": "Create a Nuxt plugin for managing impersonation sessions. Implement secure token storage with multiple verification tiers (server-verified, client-verified, storage restore, manual). Add functionality to detect token expiration and handle automatic reload when switching between admin and impersonated user contexts. Implement graceful fallback to admin context when impersonation expires.",
            "status": "done",
            "testStrategy": "Test session persistence across page reloads. Verify context switching works correctly. Test expiration handling and fallback mechanisms."
          },
          {
            "id": 3,
            "title": "Create Impersonation Banner Component with Countdown",
            "description": "Develop a UI component that displays when impersonation is active, showing session details, countdown timer, and stop functionality",
            "dependencies": [
              2
            ],
            "details": "Build a persistent banner component that appears across all pages when impersonation is active. Include a countdown timer showing remaining session time, the name of the impersonated user, and a prominent stop button to end impersonation. Ensure the banner is visually distinct and cannot be dismissed while impersonation is active. Implement real-time countdown that updates every minute.",
            "status": "done",
            "testStrategy": "Test banner visibility across different pages. Verify countdown accuracy. Test stop functionality properly ends the session."
          },
          {
            "id": 4,
            "title": "Implement Route Protection and Privilege Separation",
            "description": "Add security controls to prevent privilege blending by blocking admin routes during impersonation",
            "dependencies": [
              2
            ],
            "details": "Modify the router middleware to check for act_as claims in the current token. Block access to all admin routes when impersonation is active to prevent privilege blending. Implement appropriate error handling and user feedback when blocked routes are attempted. Create a mechanism to temporarily exit impersonation for specific admin actions if needed, with MFA re-verification.",
            "status": "done",
            "testStrategy": "Test route protection by attempting to access admin routes during impersonation. Verify appropriate redirects and error messages. Test temporary exit mechanism if implemented."
          },
          {
            "id": 5,
            "title": "Develop Comprehensive Audit Logging System",
            "description": "Create a complete audit trail for all impersonation activities in the impersonation_sessions table",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Design and implement the impersonation_sessions database table to track all impersonation events. Log the start and end of each session, including admin ID, impersonated user ID, timestamp, duration, IP address, and reason for impersonation. Add endpoints to record session events. Implement automatic logging when sessions expire naturally or are manually ended. Create an admin interface to review the audit logs with filtering and search capabilities.",
            "status": "done",
            "testStrategy": "Verify all impersonation events are properly logged. Test both manual session termination and automatic expiration logging. Validate the admin interface displays accurate log information."
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Email System with Magic Link Strategy",
        "description": "Build robust email delivery system with magic link authentication and configurable SMTP options",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "details": "Implement email system:\n- Single pre-selected email retrieval strategy for reliability (no configuration required)\n- Magic link generation for invitations with 7-day expiry\n- Magic link impersonation flow: generate without sending, immediate OTP verification\n- Integration with Supabase SMTP or custom transporter option\n- Email templates for invitations, role changes, team updates\n- Graceful degradation with cascading fallbacks for auth errors\n- User-friendly error messages and partial success handling\n- Secure token hashing for invite links\n- Complete invitation backend using Supabase's auth.admin.inviteUserByEmail()\n- Admin UI for managing pending invitations in TeamForm.vue\n- Display table for pending invitations with status\n- Revoke and resend invitation functionality",
        "testStrategy": "Email delivery tests with test SMTP server, magic link validation tests, token security tests, template rendering tests, fallback mechanism tests. Test complete invitation flow from sending invite to team membership completion. Verify UI functionality for managing pending invitations, including display, revoke, and resend features.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement SMTP Configuration and Email Transport Layer",
            "description": "Create a configurable email transport layer that supports both Supabase SMTP and custom SMTP options with fallback mechanisms",
            "dependencies": [],
            "details": "Create an EmailTransporter class that handles SMTP configuration. Implement a strategy pattern to support different email providers with Supabase as default. Add configuration validation, connection testing, and cascading fallbacks between providers when delivery fails. Include error logging and monitoring capabilities.",
            "status": "done",
            "testStrategy": "Unit test each transport strategy with mocked SMTP services. Integration tests should verify fallback mechanisms work when primary delivery fails."
          },
          {
            "id": 2,
            "title": "Develop Magic Link Token Generation and Validation",
            "description": "Create secure token generation for magic links with proper hashing, expiration handling, and validation logic",
            "dependencies": [],
            "details": "Implement a TokenService that generates cryptographically secure tokens with configurable expiration (default 7 days). Store hashed tokens in the database with creation timestamp and expiry date. Create validation methods to verify token authenticity and check expiration status. Implement token revocation functionality for security.",
            "status": "done",
            "testStrategy": "Test token generation uniqueness, proper hashing implementation, expiration validation, and token revocation. Include security-focused tests to ensure tokens cannot be tampered with."
          },
          {
            "id": 3,
            "title": "Create Email Template System with Standard Templates",
            "description": "Build a template engine for emails with standard templates for invitations, role changes, and team updates",
            "dependencies": [],
            "details": "Implement a TemplateEngine class that supports HTML and text email formats. Create base templates for all required email types (invitations, role changes, team updates). Include personalization variables, styling consistent with application branding, and responsive design. Ensure templates are accessible and render properly across email clients.",
            "status": "done",
            "testStrategy": "Verify template rendering with various input data. Test email rendering in multiple email clients. Validate HTML structure and accessibility."
          },
          {
            "id": 4,
            "title": "Implement Magic Link Invitation Flow",
            "description": "Build the end-to-end invitation flow using magic links, including generation, delivery, and user acceptance",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create an InvitationService that generates magic links using the TokenService. Implement email sending via the EmailTransporter with appropriate templates. Add endpoints for accepting invitations and verifying tokens. Include special handling for impersonation flow with OTP verification. Implement proper error handling and user feedback for failed invitations.",
            "status": "done",
            "testStrategy": "End-to-end testing of the invitation flow from generation to acceptance. Test expiration handling, invalid token scenarios, and the impersonation flow with OTP verification."
          },
          {
            "id": 5,
            "title": "Implement Error Handling and Monitoring System",
            "description": "Create comprehensive error handling for the email system with user-friendly messages and monitoring",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement a centralized error handling system for all email operations. Create user-friendly error messages for common failure scenarios. Add detailed logging for debugging purposes. Implement metrics collection for monitoring email delivery success rates, timing, and error frequencies. Create an admin dashboard component to display system health and recent email activity.",
            "status": "done",
            "testStrategy": "Test error scenarios including network failures, invalid email addresses, and template rendering issues. Verify logs contain appropriate debugging information and error messages are user-friendly."
          },
          {
            "id": 6,
            "title": "Create /accept-invite Page and Route",
            "description": "Develop the frontend page and route for accepting invitations using the existing TeamAuthConfirmation component",
            "dependencies": [
              4
            ],
            "details": "Implement the /accept-invite page using the TeamAuthConfirmation component. Ensure the page is styled consistently with the rest of the application and handles all necessary user interactions for accepting an invitation.",
            "status": "done",
            "testStrategy": "Test the page rendering and user interactions in various browsers. Verify that the page correctly integrates with the backend to complete the invitation acceptance process."
          },
          {
            "id": 7,
            "title": "Wire up acceptInvite() Method",
            "description": "Integrate the acceptInvite() method from useTeamAuth into the /accept-invite page",
            "dependencies": [
              6
            ],
            "details": "Ensure that the acceptInvite() method is correctly called when a user accepts an invitation on the /accept-invite page. Handle any errors and provide user feedback as necessary.",
            "status": "done",
            "testStrategy": "Test the integration by simulating invitation acceptance and verifying that the user is correctly added to the team. Check for proper error handling and user feedback."
          },
          {
            "id": 8,
            "title": "Test Complete Invitation Flow",
            "description": "Conduct comprehensive testing of the invitation flow from sending an invite to team membership completion",
            "dependencies": [
              7
            ],
            "details": "Perform end-to-end testing of the entire invitation process, including sending invitations, accepting them via the /accept-invite page, and verifying team membership completion.",
            "status": "done",
            "testStrategy": "Use a test environment to simulate the entire invitation flow. Verify that all steps function correctly and that users are successfully added to teams. Check for any issues in the flow and ensure all components work together seamlessly."
          },
          {
            "id": 9,
            "title": "Add Pending Invitation Management to Admin UI",
            "description": "Enhance the TeamForm.vue component to manage pending invitations",
            "dependencies": [
              4
            ],
            "details": "Implement a display table in TeamForm.vue to show pending invitations with their current status. Add functionality to revoke or resend invitations directly from the UI. Ensure the UI is intuitive and provides real-time updates on invitation status.",
            "status": "done",
            "testStrategy": "Test the UI for displaying pending invitations, revoking, and resending functionality. Verify that actions are correctly reflected in the backend and that the UI updates in real-time."
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement Role-Based Access Control and Permissions",
        "description": "Build comprehensive RBAC system with role hierarchy, permission checks, and secure role transitions",
        "details": "RBAC Implementation:\n- Role hierarchy: super_admin > owner > admin > member\n- Permission matrix for all operations (invite, promote, demote, delete, etc.)\n- Secure role transition validation (owner transfer, promotion/demotion rules)\n- Frontend permission guards for UI elements\n- Backend permission validation in Edge Functions\n- Role-based route protection middleware\n- Cascading team deletion with owner-only access\n- Prevention of self-demotion and orphaned teams\n- Integration with JWT claims for real-time permission checks",
        "testStrategy": "Permission matrix tests for all role combinations, role transition security tests, UI permission guard tests, backend authorization tests, edge case handling (self-operations, last owner scenarios).",
        "priority": "high",
        "dependencies": [
          4,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Role Hierarchy and Permission Matrix",
            "description": "Create the foundational data structures for the RBAC system by defining the role hierarchy and comprehensive permission matrix for all operations.",
            "dependencies": [],
            "details": "1. Define enum/constants for roles (super_admin, owner, admin, member)\n2. Create a hierarchical relationship map between roles\n3. Define all system operations (invite, promote, demote, delete, etc.)\n4. Build a permission matrix mapping roles to allowed operations\n5. Document the role hierarchy and permission rules\n6. Create utility functions to check if a role is higher than another",
            "status": "done",
            "testStrategy": "Unit tests for role comparison functions and permission matrix validation to ensure logical consistency in role hierarchy."
          },
          {
            "id": 2,
            "title": "Implement Backend Permission Validation",
            "description": "Build the server-side validation logic in Edge Functions to enforce permission checks based on the defined role hierarchy and permission matrix.",
            "dependencies": [
              1
            ],
            "details": "1. Create middleware for extracting user roles from JWT claims\n2. Implement permission validation functions using the permission matrix\n3. Build role transition validation logic (promotion/demotion rules)\n4. Create owner transfer validation with security checks\n5. Implement prevention of self-demotion logic\n6. Add validation to prevent orphaned teams\n7. Create reusable permission check decorators/wrappers for Edge Functions",
            "status": "done",
            "testStrategy": "Integration tests with mock JWT tokens to verify permission enforcement and role transition validation."
          },
          {
            "id": 3,
            "title": "Develop Role-Based Route Protection",
            "description": "Create middleware for protecting routes based on user roles and implement cascading team deletion with owner-only access.",
            "dependencies": [
              2
            ],
            "details": "1. Develop middleware to protect routes based on required role level\n2. Implement cascading team deletion logic with owner-only access checks\n3. Create helper functions to validate user permissions for specific resources\n4. Add logging for permission denials and role changes for audit purposes\n5. Implement rate limiting for sensitive role operations\n6. Create error handlers for unauthorized access attempts",
            "status": "done",
            "testStrategy": "API tests with different user roles to verify proper route protection and resource access control."
          },
          {
            "id": 4,
            "title": "Implement Frontend Permission Guards",
            "description": "Create UI permission guards to conditionally render elements and actions based on the user's role and permissions.",
            "dependencies": [
              1
            ],
            "details": "1. Create a client-side permission utility to check user permissions\n2. Implement conditional rendering for UI elements based on permissions\n3. Add disabled states for actions not allowed for current role\n4. Create higher-order components or hooks for permission-based rendering\n5. Implement tooltips explaining why actions are unavailable\n6. Add visual indicators of user's current role in the UI",
            "status": "done",
            "testStrategy": "Component tests with different user roles to verify correct UI rendering and interaction permissions."
          },
          {
            "id": 5,
            "title": "Integrate JWT Claims for Real-Time Permission Checks",
            "description": "Connect the RBAC system with JWT authentication to enable real-time permission checks and role updates.",
            "dependencies": [
              2,
              4
            ],
            "details": "1. Update JWT payload structure to include role and permission data\n2. Implement JWT refresh logic to update permissions after role changes\n3. Create a permission context provider for the frontend\n4. Add real-time permission validation on both client and server\n5. Implement secure storage of permission data\n6. Add event listeners for role changes to trigger permission updates\n7. Create comprehensive documentation for the RBAC implementation",
            "status": "done",
            "testStrategy": "End-to-end tests simulating role changes and verifying permission updates propagate correctly throughout the system."
          }
        ]
      },
      {
        "id": 17,
        "title": "Set up Local Supabase Development Environment",
        "description": "Configure a local Supabase development environment with database initialization, environment variables, and development tooling for the team-auth module.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "Set up comprehensive local Supabase development environment:\n\n **COMPLETED - Initialize Supabase Project**:\n   -  Run `supabase init` in the module root directory\n   -  Configure supabase/config.toml with appropriate settings for local development (MFA TOTP and email confirmations enabled)\n   -  Set up project structure with supabase/ directory containing migrations, functions, and seed data\n\n **IN PROGRESS - Local Database Configuration**:\n   -  Install and configure Docker for local PostgreSQL instance\n   -  Docker images currently downloading for Supabase services (postgres, auth, api, studio, etc.)\n   -  Run `supabase start` to spin up local development stack (pending Docker download completion)\n   -  Configure database connection settings for local development\n   -  Set up initial database schema for team authentication (users, teams, roles, permissions tables)\n\n **COMPLETED - Environment Configuration**:\n   -  Create .env.example template with all required Supabase variables\n   -  Set up .env.local for local development (ready for API keys once services start)\n   -  Populate .env.local with actual API keys from running Supabase instance\n   -  Configure environment variable validation and type safety\n\n **COMPLETED - Development Tooling Setup**:\n   -  Configure Supabase CLI commands in package.json scripts (start, stop, reset, status, migrate, generate-types)\n   -  Set up database migration workflow\n   -  Configure local testing database reset/seed procedures\n   -  Set up src/runtime/types directory for TypeScript type generation\n   -  Generate initial TypeScript types from database schema\n\n **COMPLETED - Documentation**:\n   -  Created SETUP.md with comprehensive local development instructions\n\n **PENDING - Integration with Module Structure**:\n   -  Ensure Supabase configuration works with Nuxt 3 module structure\n   -  Set up proper imports and exports for Supabase client\n   -  Configure development vs production environment handling",
        "testStrategy": "Verify local Supabase environment setup:\n\n1. **Environment Validation**:\n   - Confirm `supabase status` shows all services running (PostgreSQL, Auth, API, etc.)\n   - Verify .env files contain all required variables with correct local values\n   - Test environment variable loading in development mode\n\n2. **Database Connectivity**:\n   - Successfully connect to local PostgreSQL instance using provided credentials\n   - Verify Supabase client can authenticate with local anon and service role keys\n   - Test basic database operations (SELECT, INSERT) through Supabase client\n\n3. **Development Workflow**:\n   - Run `supabase db reset` and verify clean database state\n   - Test migration application and rollback procedures\n   - Verify local development server can access Supabase services without errors\n\n4. **Module Integration**:\n   - Confirm Nuxt 3 module can import and use Supabase client in development\n   - Test that TypeScript types are properly generated and accessible\n   - Verify no conflicts between Supabase configuration and module structure\n\n5. **Documentation Verification**:\n   - Ensure setup instructions are complete and reproducible\n   - Verify all required dependencies and prerequisites are documented\n   - Test setup process on clean environment to confirm completeness",
        "subtasks": [
          {
            "id": "17.1",
            "title": "Complete Docker image download and start Supabase services",
            "description": "Wait for Docker images to finish downloading, then start the local Supabase stack",
            "status": "done"
          },
          {
            "id": "17.2",
            "title": "Capture and configure API keys",
            "description": "Once Supabase services are running, capture the local API keys and populate .env.local file",
            "status": "done"
          },
          {
            "id": "17.3",
            "title": "Set up initial database schema",
            "description": "Create initial database schema for team authentication (users, teams, roles, permissions tables)",
            "status": "done"
          },
          {
            "id": "17.4",
            "title": "Generate TypeScript types",
            "description": "Run type generation to create TypeScript definitions from the database schema",
            "status": "done"
          },
          {
            "id": "17.5",
            "title": "Configure environment variable validation",
            "description": "Set up environment variable validation and type safety for the module",
            "status": "done"
          },
          {
            "id": "17.6",
            "title": "Integrate with Nuxt 3 module structure",
            "description": "Ensure Supabase configuration works properly with the Nuxt 3 module structure and set up client imports/exports",
            "status": "done"
          }
        ]
      },
      {
        "id": 19,
        "title": "Session Management System",
        "description": "Implement robust session management with token refresh, persistence, and cleanup",
        "details": "Add functionality to handle user sessions including automatic token refresh, session persistence across browser refreshes, and proper session cleanup on logout",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Token Refresh Logic",
            "description": "Create automatic token refresh mechanism to handle expired JWT tokens",
            "details": "Build logic to detect token expiration and automatically refresh tokens before they expire",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 19
          }
        ]
      },
      {
        "id": 21,
        "title": "Implement Critical RLS Security Policies",
        "description": "Create Row Level Security policies for all tables - this is currently missing and represents a major security vulnerability. Implement team-scoped access control for teams, team_members, invites, and impersonation_sessions tables.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Create Universal Confirmation Handler",
        "description": "Implement a single confirmation page that handles both email confirmation after signup AND invitation acceptance, following the pattern from the reference implementation. Include hash parameter fallback for email clients that strip query strings.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Implement Session Persistence and State Management",
        "description": "Add localStorage and sessionStorage integration for session persistence across page reloads. Implement proper session restoration and state hydration for the useTeamAuth composable, including impersonation context preservation.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Create Authentication Middleware and Route Protection",
        "description": "Implement Nuxt middleware for route protection based on authentication status and user roles. Add global authentication checks and redirection logic for protected routes.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          4,
          21
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Write Tests for Authentication Middleware",
            "description": "Create comprehensive unit and integration tests for all middleware functions including authentication checks, role-based access control, team membership verification, and redirection logic. Test both positive and negative scenarios.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 24
          }
        ]
      },
      {
        "id": 25,
        "title": "Create Helper Functions for Secure Database Operations",
        "description": "Implement SQL helper functions with SECURITY DEFINER for safe privilege escalation and team context scoping. Add functions for current_user_team(), user role checks, and other database utilities needed for RLS policies.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          21
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Enhance Invitation System with Better Tracking",
        "description": "Improve the invites table to include status tracking (accepted_at, expires_at fields), custom token storage for fallback scenarios, and better audit trails while preserving our simplified auth.admin.inviteUserByEmail() approach.",
        "details": "",
        "testStrategy": "",
        "status": "cancelled",
        "dependencies": [
          3,
          21
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Add User Profile Storage and Management",
        "description": "Create a users profile table or extend auth.users metadata to store user information like first_name, last_name, and other profile data. This enables better user management and profile features.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          21
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Set Up Testing Infrastructure and Framework",
        "description": "Configure comprehensive testing environment with Vitest for unit tests, Playwright for E2E tests, and testing utilities for Nuxt composables and Edge Functions. Set up test databases, mocking strategies, and CI/CD integration following TDD best practices.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Vitest for Unit Testing",
            "description": "Set up Vitest as the primary unit testing framework with TypeScript support, Vue component testing utilities, and mocking capabilities for Supabase clients",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 28
          },
          {
            "id": 2,
            "title": "Set Up Playwright for E2E Testing",
            "description": "Configure Playwright for end-to-end testing with cross-browser support, test database setup/teardown, and Supabase local environment integration",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 28
          },
          {
            "id": 3,
            "title": "Create Test Database Setup and Helpers",
            "description": "Create test database utilities for seeding data, cleaning up between tests, and managing test user accounts. Include helpers for creating test teams and users with different roles",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 28
          },
          {
            "id": 4,
            "title": "Configure CI/CD Test Pipeline",
            "description": "Set up GitHub Actions workflow for automated testing including unit tests, integration tests, and E2E tests with coverage reporting and performance benchmarks",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 28
          }
        ]
      },
      {
        "id": 29,
        "title": "Write Unit Tests for useTeamAuth Composable",
        "description": "Implement comprehensive unit tests for the useTeamAuth composable using a Test-Driven Development (TDD) approach. Focus on testing all methods, including signUpWithTeam, signIn, signOut, team management, and impersonation. Ensure coverage of input/output pairs, error scenarios, and state management, with particular attention to session persistence and dual-session handling.",
        "status": "done",
        "dependencies": [
          4,
          28
        ],
        "priority": "high",
        "details": "Significant progress has been made in developing the useTeamAuth composable with a focus on testability through dependency injection. Key issues such as session state initialization, JWT parsing, and asynchronous timing have been addressed. Currently, 14 out of 17 tests are passing, achieving an 82% success rate. The remaining three tests are encountering minor issues related to mock setup. The core business logic has been validated, covering areas like state management, JWT claims parsing, authentication orchestration, error handling, permission checks, team management, and impersonation validation. External dependencies, including Supabase API calls and browser storage APIs, are being appropriately mocked.",
        "testStrategy": "Continue refining the unit tests to achieve full coverage and resolve the remaining mock setup issues. Ensure that all tests accurately reflect the intended behavior of the useTeamAuth composable, particularly focusing on the areas where issues have been identified. Maintain the use of dependency injection to facilitate testability and mock external dependencies as needed.",
        "subtasks": [
          {
            "id": 1,
            "title": "Resolve Mock Setup Issues in Remaining Tests",
            "description": "Investigate and fix the three unit tests that are currently failing due to mock setup issues. Ensure that all external dependencies are correctly mocked and that the tests accurately reflect the intended behavior of the useTeamAuth composable.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Verify Comprehensive Test Coverage",
            "description": "Review the existing unit tests to confirm that all methods and scenarios of the useTeamAuth composable are adequately covered. Identify any gaps in test coverage and implement additional tests as necessary.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Document Test Cases and Results",
            "description": "Create detailed documentation for all unit tests, including descriptions of test cases, expected outcomes, and actual results. Highlight any areas where issues were identified and how they were resolved.",
            "status": "done"
          }
        ]
      },
      {
        "id": 30,
        "title": "Write Unit Tests for Supabase Edge Functions",
        "description": "Create comprehensive unit tests for all Edge Functions (create-team-and-owner, invite-member, accept-invite, start-impersonation, stop-impersonation, transfer-ownership) using TDD methodology. Test input validation, error handling, permission checks, and expected outputs with mocked Supabase clients.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          3,
          28
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Package Current Project as a Distributable Nuxt Module",
        "description": "Analyze the current project structure and package it as a Nuxt module following best practices.",
        "details": "1. Research Nuxt module packaging best practices, focusing on structure, configuration, and distribution.\n2. Examine the current codebase to identify components, utilities, and configurations that should be exposed as part of the module versus those that should remain internal.\n3. Define the module's entry points and ensure compatibility with both ESM and CJS.\n4. Plan and implement a build process that compiles the module for distribution, including bundling and minification.\n5. Set up npm/pnpm scripts for building, testing, and publishing the module.\n6. Ensure the package.json is correctly configured with metadata, dependencies, and peer dependencies.\n7. Document the module's API, installation instructions, and usage examples.\n8. Consider versioning strategy and semantic versioning for future updates.",
        "testStrategy": "1. Verify the module can be installed and used in a fresh Nuxt 3 project.\n2. Test the module's API to ensure all exposed functions and components work as expected.\n3. Run integration tests to confirm the module integrates smoothly with existing Nuxt 3 applications.\n4. Use tools like np and npm pack to simulate publishing and ensure the package is correctly structured.\n5. Validate the module's compatibility with both ESM and CJS environments.\n6. Review documentation for accuracy and completeness, ensuring it covers all aspects of installation and usage.",
        "status": "done",
        "dependencies": [
          1,
          4,
          5
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Document and validate server endpoint handling",
            "description": "Ensure comprehensive understanding of how the module handles server-side endpoints and middleware for team authentication",
            "details": "1. Document all server endpoints used by the module (signup, signin, team management)\\n2. Verify middleware integration and how it affects consuming projects\\n3. Test server-side rendering compatibility\\n4. Validate API route generation and handling\\n5. Ensure proper error handling and response formatting",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 2,
            "title": "Create test project that uses the module",
            "description": "Set up a separate test project to validate the module works correctly when installed as a dependency",
            "details": "1. Create a fresh Nuxt 3 project in a separate directory\\n2. Install the packaged module as a dependency\\n3. Configure the module in the test project\\n4. Implement basic team authentication features using the module\\n5. Test all major module functionality (signup, signin, team management)\\n6. Validate that the module doesn't conflict with other Nuxt modules\\n7. Test development and production builds",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 3,
            "title": "Test Supabase integration with existing project",
            "description": "Validate how the module integrates with projects that already have Supabase configured",
            "details": "1. Set up a test project with existing Supabase configuration\\n2. Install and configure the team auth module\\n3. Verify that module doesn't conflict with existing Supabase setup\\n4. Test database schema migration and integration\\n5. Validate RLS policies work alongside existing policies\\n6. Ensure auth flows don't interfere with existing authentication\\n7. Document any configuration requirements or conflicts\\n8. Test edge cases where tables or policies might already exist",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 4,
            "title": "Test Supabase integration with fresh project",
            "description": "Validate how the module works with projects that don't have any existing Supabase configuration",
            "details": "1. Create a fresh Nuxt 3 project without Supabase\\n2. Install the team auth module\\n3. Test the module's ability to bootstrap Supabase configuration\\n4. Verify automatic database schema setup and migrations\\n5. Test the complete setup flow from scratch\\n6. Validate that all required dependencies are properly installed\\n7. Ensure the module provides clear setup instructions\\n8. Test both local development and production deployment scenarios\\n9. Document the complete setup process for new projects",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 5,
            "title": "Create comprehensive module documentation",
            "description": "Develop complete documentation for the module including API reference, setup guides, and examples",
            "details": "1. Create README.md with installation and quick start guide\\n2. Document module configuration options and environment variables\\n3. Create API reference for all exposed components, composables, and utilities\\n4. Write setup guides for both fresh and existing Supabase projects\\n5. Document database schema requirements and migrations\\n6. Create usage examples for common scenarios (signup, team management, etc.)\\n7. Document troubleshooting common issues\\n8. Create migration guide from standalone to module usage\\n9. Document TypeScript types and interfaces\\n10. Add JSDoc comments to all public APIs",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          },
          {
            "id": 6,
            "title": "Document Required Pages for Implementing Applications",
            "description": "Create comprehensive documentation about pages that implementing applications must create, including the /accept-invite page and other required authentication pages",
            "details": "1. Document required pages like /accept-invite with URL parameters, implementation examples, and integration patterns\n2. Provide complete code examples for each required page\n3. Document optional pages and common patterns\n4. Include error handling and UX guidance",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 36
          }
        ]
      },
      {
        "id": 37,
        "title": "Roadmap - Future Enhancements",
        "description": "Create a container task for tracking potential future enhancements and nice-to-have features post-MVP.",
        "details": "This task serves as a placeholder for collecting and organizing ideas for future enhancements that are not critical for the MVP but could significantly improve the product. These enhancements might include additional features, performance optimizations, UI/UX improvements, or integrations with other services. The task should be regularly updated with new ideas as they arise and prioritized based on user feedback and strategic goals. This task will not have direct implementation work but will guide future development efforts.",
        "testStrategy": "Verify that the task is used to collect and document potential enhancements. Ensure that each enhancement idea is clearly described, including its potential impact, estimated effort, and any dependencies. Regularly review and update the list to reflect current priorities and strategic direction.",
        "status": "pending",
        "dependencies": [
          11
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CLI Tool for Project Initialization and Migrations",
            "description": "Build the team-auth CLI tool for init and migrate commands with automatic Supabase integration",
            "status": "pending",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement CLI with commands:\n- team-auth init: Copy migrations to supabase/migrations/team-auth/, copy edge functions to supabase/functions/team-auth/, detect Supabase project linking, auto-run supabase db push, add package.json scripts\n- team-auth migrate: Apply new migrations in order, verify schema version compatibility\n\nFeatures:\n- Detect existing Supabase CLI installation and project linking\n- Version-aware migration system (patch/minor/major versioning policy)\n- Automatic file copying with proper directory structure\n- Integration with Supabase CLI commands\n- Clear user feedback and error messages\n- Commit reminders for CI/CD integration",
            "testStrategy": "CLI integration tests with mocked file system and Supabase CLI. Version compatibility tests. Error handling tests for missing dependencies."
          },
          {
            "id": 2,
            "title": "Add Internationalization and Accessibility Features",
            "description": "Implement i18n support with externalized strings and ensure WCAG 2.1 AA compliance across all components",
            "status": "pending",
            "dependencies": [
              5
            ],
            "details": "Internationalization:\n- Externalize all user-facing strings to JSON files\n- Default English locale with override mechanism\n- Support for custom locale JSON files\n- Integration with Nuxt i18n module\n- Pluralization support for dynamic content\n\nAccessibility:\n- WCAG 2.1 AA compliance across all components\n- Keyboard navigation support\n- Screen reader compatibility with proper ARIA labels\n- Focus management for modals and dropdowns\n- Color contrast validation\n- Alternative text for all images and icons\n- Semantic HTML structure",
            "testStrategy": "Accessibility audit with axe-core, keyboard navigation tests, screen reader tests with NVDA/JAWS, color contrast validation, i18n tests with multiple locales."
          },
          {
            "id": 3,
            "title": "Create Demo Application and Documentation",
            "description": "Build comprehensive demo application showcasing all features with complete documentation and integration guides",
            "status": "pending",
            "dependencies": [
              5,
              7,
              9
            ],
            "details": "Demo Application:\n- Complete Nuxt 3 app demonstrating all team-auth features\n- Example pages: sign-up, dashboard, team management, profile, admin panel\n- Integration examples with different UI frameworks\n- Performance optimization examples\n- Error handling demonstrations\n\nDocumentation:\n- Installation and setup guide\n- API reference for useTeamAuth composable\n- Component documentation with props/slots/events\n- Migration guide and versioning policy\n- Security best practices\n- Troubleshooting guide\n- Integration examples with popular Nuxt modules\n- Performance optimization tips",
            "testStrategy": "Documentation accuracy tests, demo app functionality tests, integration guide validation, performance benchmarks against 150ms P95 latency requirement."
          },
          {
            "id": 4,
            "title": "Add Multi-Factor Authentication Integration",
            "description": "Implement MFA toggle functionality with TOTP support and enforce MFA for super-admin operations",
            "status": "pending",
            "dependencies": [
              4,
              6
            ],
            "details": "MFA Implementation:\n- TOTP (Time-based One-Time Password) support using authenticator apps\n- MFA enrollment flow with QR code generation\n- MFA toggle in user profile settings\n- Mandatory MFA for super-admin role\n- MFA verification before impersonation start\n- Backup codes generation and validation\n- MFA recovery flow for lost devices\n- Integration with Supabase Auth MFA features\n- Graceful fallback for MFA failures\n- MFA status indicators in UI components",
            "testStrategy": "MFA enrollment tests, TOTP validation tests, backup code tests, super-admin MFA enforcement tests, recovery flow tests, integration tests with authenticator apps."
          },
          {
            "id": 5,
            "title": "Implement Performance Optimization and Caching",
            "description": "Add performance optimizations, caching strategies, and monitoring to meet the 150ms P95 latency requirement",
            "status": "pending",
            "dependencies": [
              4,
              5
            ],
            "details": "Performance Optimization:\n- Client-side caching for team data and user profiles\n- Optimistic updates for UI responsiveness\n- Lazy loading for non-critical components\n- Database query optimization with proper indexing\n- Edge Function response caching where appropriate\n- Bundle size optimization with tree shaking\n- Image optimization for avatars and assets\n- Connection pooling for database operations\n- CDN integration for static assets\n\nMonitoring:\n- Performance metrics collection\n- Latency monitoring for auth operations\n- Error rate tracking\n- User experience metrics\n- Database performance monitoring",
            "testStrategy": "Performance benchmarking against 150ms P95 target, load testing with concurrent users, cache effectiveness tests, bundle size analysis, database query performance tests."
          },
          {
            "id": 6,
            "title": "Set up GitHub Repository with gh CLI and Project Configuration",
            "description": "Initialize a GitHub repository for the nuxt-supabase-team-auth project using gh CLI with proper configuration, documentation, and repository settings.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Set up the GitHub repository infrastructure for the project:\n\n1. **Repository Creation with gh CLI:**\n   - Use `gh repo create nuxt-supabase-team-auth --public --clone` to create and clone repository\n   - Configure repository description: \"A Nuxt 3 module for team-based authentication with Supabase\"\n   - Set repository topics: nuxt, supabase, authentication, team-management, typescript\n\n2. **Repository Configuration:**\n   - Enable GitHub Pages for documentation hosting\n   - Configure branch protection rules for main branch\n   - Set up issue and PR templates in .github/ directory\n   - Configure repository settings for security and collaboration\n\n3. **Documentation Setup:**\n   - Create comprehensive README.md with project overview, installation, usage examples\n   - Include badges for build status, npm version, license\n   - Add getting started guide and API documentation structure\n   - Create CONTRIBUTING.md with development guidelines\n\n4. **License and Legal:**\n   - Add MIT license file using `gh repo edit --add-license mit`\n   - Create CODE_OF_CONDUCT.md for community guidelines\n   - Add SECURITY.md for vulnerability reporting\n\n5. **Initial Repository Structure:**\n   - Set up .gitignore for Node.js, Nuxt, and IDE files\n   - Configure .github/workflows/ directory for future CI/CD\n   - Add package.json validation and sync with repository metadata\n   - Create initial directory structure aligned with Nuxt 3 module standards\n\n6. **Repository Metadata:**\n   - Configure repository homepage URL\n   - Set up repository social preview image\n   - Add relevant keywords and description for discoverability",
            "testStrategy": "Verify repository setup completion:\n\n1. **Repository Verification:**\n   - Confirm repository exists and is publicly accessible on GitHub\n   - Verify repository description, topics, and metadata are correctly set\n   - Check that repository homepage and social preview are configured\n\n2. **Documentation Quality Check:**\n   - Validate README.md renders correctly with all sections and badges\n   - Ensure all links in documentation are functional\n   - Verify license file is properly recognized by GitHub\n   - Check that CONTRIBUTING.md and CODE_OF_CONDUCT.md are accessible\n\n3. **Repository Configuration Testing:**\n   - Test branch protection rules are active on main branch\n   - Verify issue and PR templates are available when creating new issues/PRs\n   - Confirm GitHub Pages is enabled and accessible\n   - Check repository settings match security and collaboration requirements\n\n4. **Local Development Setup:**\n   - Clone repository locally and verify all files are present\n   - Ensure .gitignore properly excludes intended files\n   - Validate package.json metadata matches repository information\n   - Test that repository structure aligns with Nuxt 3 module conventions\n\n5. **Integration Verification:**\n   - Confirm gh CLI commands work correctly with the repository\n   - Verify repository can be found through GitHub search with configured topics\n   - Test that repository is ready for future CI/CD pipeline integration"
          },
          {
            "id": 7,
            "title": "Implement End-to-End Testing with Playwright",
            "description": "Set up Playwright E2E testing framework for complete user journey testing including signup, team management, impersonation workflows, and cross-browser compatibility. Include test data seeding, cleanup, and CI/CD integration.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 37
          },
          {
            "id": 8,
            "title": "Implement Security Hardening and Audit Logging",
            "description": "Add comprehensive security measures, audit logging, and vulnerability prevention mechanisms",
            "status": "pending",
            "dependencies": [
              6,
              10
            ],
            "details": "Security Hardening:\n- JWT signature validation with custom claims verification\n- Rate limiting for sensitive operations (invites, role changes)\n- CSRF protection for state-changing operations\n- Input validation and sanitization\n- SQL injection prevention in custom queries\n- Secure token generation and hashing\n- Session fixation prevention\n- Privilege escalation detection and prevention\n\nAudit Logging:\n- Immutable audit trail for all team operations\n- 1-year retention policy for impersonation sessions\n- Comprehensive logging for role changes, invitations, deletions\n- Security event logging (failed auth, suspicious activity)\n- Log integrity verification\n- GDPR-compliant data handling",
            "testStrategy": "Security penetration testing, audit log integrity tests, privilege escalation prevention tests, rate limiting validation, input sanitization tests, session security tests."
          },
          {
            "id": 9,
            "title": "Create Comprehensive Test Suite and CI/CD Pipeline",
            "description": "Build complete testing infrastructure with unit, integration, and E2E tests achieving 90% coverage",
            "status": "pending",
            "dependencies": [
              11,
              12,
              13,
              14
            ],
            "details": "Test Suite:\n- Unit tests for all composables, components, and utilities (Jest/Vitest)\n- Integration tests for Supabase Edge Functions and database operations\n- E2E tests for complete user flows (Cypress/Playwright)\n- Component testing with Vue Test Utils\n- API testing for all endpoints\n- Security testing for auth flows and permissions\n- Performance testing for latency requirements\n- Accessibility testing with automated tools\n\nCI/CD Pipeline:\n- Automated testing on pull requests\n- Code coverage reporting with 90% target\n- Security scanning with dependency checks\n- Lighthouse performance and accessibility audits (90 a11y score)\n- Automated deployment to staging environment\n- Release automation with semantic versioning\n- Database migration testing\n- Cross-browser compatibility testing",
            "testStrategy": "Meta-testing: Validate test coverage accuracy, CI/CD pipeline reliability, test execution performance, flaky test detection and resolution."
          },
          {
            "id": 10,
            "title": "Write Integration Tests for Database Operations and RLS",
            "description": "Implement integration tests for database schema, RLS policies, and SQL helper functions using real Supabase test database. Test team-scoped data access, permission boundaries, and cross-user data isolation. Verify RLS policies block unauthorized access and allow proper team member access.",
            "status": "pending",
            "dependencies": [
              21,
              25,
              28
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Write Component Tests for Vue UI Components",
            "description": "Create unit and integration tests for all Vue components (AuthSignIn, AuthSignUpWithTeam, UserButton, ProfileForm, TeamMembersTable, TeamSettingsModal, SignedIn, SignedOut) using Vue Test Utils. Test component rendering, user interactions, prop handling, and integration with useTeamAuth composable.",
            "status": "pending",
            "dependencies": [
              5,
              29,
              28
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "Write End-to-End Tests for Complete User Flows",
            "description": "Implement E2E tests using Playwright covering complete user journeys: signup with team creation, invitation flow, team management, role changes, impersonation workflow, and session persistence across page reloads. Test both happy paths and error scenarios with real Supabase backend.",
            "status": "pending",
            "dependencies": [
              22,
              23,
              24,
              28
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 13,
            "title": "Write Security and Performance Tests",
            "description": "Create specialized tests for security vulnerabilities (SQL injection, privilege escalation, session hijacking) and performance benchmarks (150ms P95 latency requirement). Include load testing for Edge Functions and stress testing for concurrent impersonation sessions.",
            "status": "pending",
            "dependencies": [
              12,
              14,
              28
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 14,
            "title": "Write Tests for CLI Tool and Module Integration",
            "description": "Create tests for the CLI tool commands (init, migrate), module installation process, and integration with consuming Nuxt applications. Test schema migration workflows, Edge Function deployment, and module configuration in various project setups.",
            "status": "pending",
            "dependencies": [
              7,
              28
            ],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 15,
            "title": "Complete Nuxt Module Packaging and Distribution Setup",
            "description": "Finalize the setup for distributing the project as a Nuxt module, including server API route handling, Supabase integration, and TypeScript exports.",
            "status": "pending",
            "dependencies": [
              1,
              3,
              4
            ],
            "details": "To complete the Nuxt module packaging and distribution setup, follow these steps: 1. Ensure the module is structured according to Nuxt 3 guidelines, building upon the initial setup from Task 1. 2. Implement server API route handling within the module, ensuring routes are correctly registered and accessible. 3. Develop strategies for integrating Supabase configuration, accommodating both projects with existing Supabase setups and those without. This includes handling environment variables securely and providing clear documentation for users. 4. Configure TypeScript exports to ensure compatibility and ease of use in consuming projects. 5. Test the module installation via npm in other projects, verifying that all functionalities, including Supabase integration and API routes, work seamlessly. 6. Update documentation to guide users through installation, configuration, and usage of the module.",
            "testStrategy": "1. Verify that the module can be installed in a fresh Nuxt 3 project via npm and that all functionalities work as expected. 2. Test server API routes to ensure they are correctly registered and accessible. 3. Validate Supabase integration by setting up a test project with and without existing Supabase configurations, ensuring environment variables are managed correctly. 4. Check TypeScript exports for correctness and usability in consuming projects. 5. Conduct end-to-end tests in a sample project to ensure the module's features integrate smoothly with other Nuxt components and plugins. 6. Review and test the documentation by following the installation and configuration steps to ensure clarity and completeness."
          }
        ]
      },
      {
        "id": 38,
        "title": "Develop Unit Tests for Middleware Functions",
        "description": "Create comprehensive unit tests for middleware functions focusing on isolated logic, edge cases, and specific route protection scenarios.",
        "status": "pending",
        "dependencies": [
          24,
          4
        ],
        "priority": "medium",
        "details": "Develop unit tests for middleware functions to ensure isolated logic is thoroughly tested without relying on mocked implementations. Focus on edge cases such as session expiration, network errors, malformed parameters, role hierarchy, and complex middleware combinations. Additionally, include tests for specific route protection scenarios: protected route middleware behavior, admin route middleware with role hierarchy, team-specific route validation, owner-only route protection, impersonation route blocking (admin routes blocked during impersonation), complex nested route requirements, optional team parameter handling, and concurrent middleware execution testing. These tests should complement existing integration tests by providing detailed coverage of unit-level behavior. Use a testing framework like Jest to write and execute these tests, ensuring each middleware function is tested in isolation. Consider using dependency injection or similar techniques to isolate middleware logic from external dependencies. Ensure that tests are written to cover all possible edge cases and scenarios, particularly those that are not covered by integration tests.",
        "testStrategy": "1. Use Jest to write unit tests for each middleware function. \n2. Test middleware functions in isolation, ensuring no external dependencies are mocked. \n3. Cover edge cases such as session expiration, network errors, malformed parameters, role hierarchy, and complex middleware combinations. \n4. Include tests for specific route protection scenarios: protected route middleware behavior, admin route middleware with role hierarchy, team-specific route validation, owner-only route protection, impersonation route blocking, complex nested route requirements, optional team parameter handling, and concurrent middleware execution testing. \n5. Verify that each test accurately reflects the middleware's expected behavior in these scenarios. \n6. Run the tests and ensure all pass successfully. \n7. Review test coverage reports to ensure comprehensive coverage of middleware logic.",
        "subtasks": [
          {
            "id": 39,
            "title": "Implement unit tests for protected route middleware behavior",
            "description": "Develop unit tests to verify the behavior of middleware protecting specific routes, ensuring unauthorized access is blocked.",
            "status": "pending"
          },
          {
            "id": 40,
            "title": "Implement unit tests for admin route middleware with role hierarchy",
            "description": "Create unit tests to ensure that admin routes are protected based on role hierarchy, allowing only authorized roles to access.",
            "status": "pending"
          },
          {
            "id": 41,
            "title": "Implement unit tests for team-specific route validation",
            "description": "Write unit tests to validate middleware behavior for routes specific to team contexts, ensuring correct team access.",
            "status": "pending"
          },
          {
            "id": 42,
            "title": "Implement unit tests for owner-only route protection",
            "description": "Develop unit tests to verify that routes restricted to owners are correctly protected by middleware.",
            "status": "pending"
          },
          {
            "id": 43,
            "title": "Implement unit tests for impersonation route blocking",
            "description": "Create unit tests to ensure that admin routes are blocked during impersonation sessions.",
            "status": "pending"
          },
          {
            "id": 44,
            "title": "Implement unit tests for complex nested route requirements",
            "description": "Write unit tests to verify middleware behavior for routes with complex nested requirements.",
            "status": "pending"
          },
          {
            "id": 45,
            "title": "Implement unit tests for optional team parameter handling",
            "description": "Develop unit tests to ensure middleware correctly handles optional team parameters in routes.",
            "status": "pending"
          },
          {
            "id": 46,
            "title": "Implement unit tests for concurrent middleware execution",
            "description": "Create unit tests to verify the behavior of middleware when executed concurrently.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 39,
        "title": "Document Simplified Invitation Approach Using Supabase",
        "description": "Update documentation and code comments to reflect the current invitation approach using Supabase's auth.users table and auth.admin.inviteUserByEmail() method.",
        "details": "1. Review the current implementation of the invitation system that uses Supabase's auth.users table instead of custom tracking tables.\\n2. Update the documentation to clearly describe the use of auth.admin.inviteUserByEmail() with team metadata in options.\\n3. Document how admin tracking is performed by querying the auth.users table, specifically focusing on the invited_at, email_confirmed_at, and raw_user_meta_data fields.\\n4. Ensure that all relevant code comments are updated to reflect these changes, providing clear guidance for future developers.\\n5. Coordinate with the team to ensure that the documentation aligns with the current system architecture and practices.",
        "testStrategy": "1. Verify that the updated documentation accurately reflects the current implementation of the invitation system.\\n2. Check that all code comments are clear and provide sufficient context for developers.\\n3. Ensure that the documentation includes examples of how to use auth.admin.inviteUserByEmail() and how to query auth.users for tracking purposes.\\n4. Conduct a peer review with team members to confirm the clarity and accuracy of the documentation updates.",
        "status": "done",
        "dependencies": [
          3,
          17
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Security Review Remediation: Address Critical Security Vulnerabilities",
        "description": "Comprehensive security remediation addressing exposed credentials, CORS configuration, token storage, debug mode settings, and other identified security vulnerabilities from security review.",
        "details": "1. Audit and secure credential management:\n   - Remove any hardcoded credentials from codebase\n   - Implement proper environment variable usage for all sensitive data\n   - Add .env files to .gitignore if not already present\n   - Rotate any exposed credentials in production\n\n2. Configure CORS policies:\n   - Review and restrict CORS origins to only necessary domains\n   - Implement proper preflight request handling\n   - Remove wildcard (*) origins from production configuration\n   - Test CORS policy effectiveness with various origin requests\n\n3. Secure token storage and handling:\n   - Implement secure token storage using httpOnly cookies where possible\n   - Add token expiration and refresh mechanisms\n   - Ensure tokens are cleared on logout\n   - Implement proper CSRF protection for token-based requests\n\n4. Production security hardening:\n   - Disable debug mode in production environments\n   - Remove development-only middleware and error handlers\n   - Implement proper error handling without exposing internal details\n   - Add security headers (CSP, HSTS, X-Frame-Options, etc.)\n\n5. Edge Function security:\n   - Review and validate all input parameters\n   - Implement rate limiting for sensitive operations\n   - Add proper authentication checks for all endpoints\n   - Ensure RLS policies are enforced consistently\n\n6. Session and authentication security:\n   - Implement session timeout and renewal\n   - Add brute force protection for login attempts\n   - Ensure proper session invalidation on security events\n   - Review impersonation security controls",
        "testStrategy": "1. Credential Security Testing:\n   - Scan codebase for hardcoded secrets using tools like git-secrets or truffleHog\n   - Verify all environment variables are properly configured\n   - Test that application fails gracefully when credentials are missing\n   - Confirm no sensitive data appears in logs or error messages\n\n2. CORS Configuration Testing:\n   - Test requests from unauthorized origins are blocked\n   - Verify preflight requests work correctly for authorized origins\n   - Test various HTTP methods and headers against CORS policy\n   - Use browser developer tools to confirm CORS headers are present\n\n3. Token Security Testing:\n   - Verify tokens are stored securely (httpOnly cookies vs localStorage)\n   - Test token expiration and refresh functionality\n   - Confirm tokens are properly cleared on logout\n   - Test CSRF protection is working for authenticated requests\n\n4. Production Hardening Testing:\n   - Verify debug mode is disabled in production builds\n   - Test that error messages don't expose sensitive information\n   - Use security scanning tools to verify security headers are present\n   - Test application behavior under various attack scenarios\n\n5. Edge Function Security Testing:\n   - Test input validation with malformed and malicious payloads\n   - Verify rate limiting is working for sensitive endpoints\n   - Test authentication requirements for all protected functions\n   - Confirm RLS policies prevent unauthorized data access\n\n6. Authentication Security Testing:\n   - Test session timeout and renewal mechanisms\n   - Verify brute force protection is active\n   - Test session invalidation works correctly\n   - Review impersonation controls and audit logging",
        "status": "done",
        "dependencies": [
          21,
          23,
          30
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove hard-coded Supabase keys from repository",
            "description": "Remove real Supabase anon and service-role keys from .env.local file (lines 5-11) and add to .gitignore",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 40
          },
          {
            "id": 2,
            "title": "Restrict CORS headers in edge functions",
            "description": "Replace wildcard '*' Access-Control-Allow-Origin headers in all Supabase edge functions with specific allowed origins",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 40
          },
          {
            "id": 3,
            "title": "Implement secure token storage",
            "description": "Replace localStorage with more secure storage for impersonation tokens and session data in useTeamAuth.ts (lines 24-60)",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 40
          },
          {
            "id": 4,
            "title": "Disable debug mode in production",
            "description": "Update nuxt.config.ts to disable teamAuth.debug in production environments to prevent sensitive information leakage",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 40
          }
        ]
      },
      {
        "id": 41,
        "title": "Performance Profiling: Analyze Auth Component Loading Times",
        "description": "Investigate and profile the performance bottlenecks causing auth elements to take several seconds to load, identifying specific areas for optimization.",
        "details": "Implement comprehensive performance profiling for auth components:\n\n1. **Component Load Time Analysis:**\n   - Add performance.mark() calls to track component initialization times\n   - Profile UserButton, ProfileForm, and AuthSignUpWithTeam components\n   - Measure time from component mount to full render\n   - Track async operations like user data fetching and team membership queries\n\n2. **Database Query Performance:**\n   - Profile Supabase queries in auth flows (user profile, team membership)\n   - Add timing logs to server-side auth operations\n   - Analyze RLS policy execution times\n   - Check for N+1 query patterns in team/user relationships\n\n3. **Dev Server vs Production Analysis:**\n   - Compare performance between dev server and production builds\n   - Profile HMR impact on auth component re-rendering\n   - Measure bundle size impact of auth-related code\n   - Check for development-only overhead in auth flows\n\n4. **Network Request Profiling:**\n   - Use browser DevTools to analyze auth-related network requests\n   - Profile Edge Function response times for auth operations\n   - Check for unnecessary round trips in auth state management\n   - Analyze caching effectiveness for user/team data\n\n5. **Client-Side Performance:**\n   - Profile JavaScript execution time in auth components\n   - Check for expensive reactive computations in auth state\n   - Analyze component re-render frequency\n   - Profile useTeamAuthConfig composable performance",
        "testStrategy": "1. **Performance Benchmarking:**\n   - Establish baseline performance metrics for auth component loading\n   - Use Chrome DevTools Performance tab to record detailed traces\n   - Run Lighthouse audits focusing on auth-heavy pages\n   - Create automated performance tests using Playwright or similar\n\n2. **Load Testing:**\n   - Test auth performance under various network conditions (3G, slow WiFi)\n   - Simulate different user scenarios (new user, returning user, team member)\n   - Test with different team sizes and user counts\n   - Verify performance in both dev and production environments\n\n3. **Profiling Validation:**\n   - Confirm performance markers are accurately capturing bottlenecks\n   - Validate that identified slow operations match user experience\n   - Test performance improvements after optimization implementation\n   - Document performance regression thresholds for future monitoring",
        "status": "done",
        "dependencies": [
          6,
          10,
          40
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Performance Monitoring Infrastructure",
            "description": "Implement performance measurement utilities and logging infrastructure to track auth component performance metrics across the application.",
            "dependencies": [],
            "details": "Create a performance utility module in `/src/runtime/utils/performance.ts` with functions for marking performance milestones, measuring durations, and logging results. Add console grouping for organized performance logs. Implement performance.mark() and performance.measure() wrappers with consistent naming conventions for auth-related operations.",
            "status": "done",
            "testStrategy": "Verify performance marks are created correctly and measurements are logged with proper timing data in browser DevTools Performance tab."
          },
          {
            "id": 2,
            "title": "Profile Auth Component Loading and Rendering",
            "description": "Add comprehensive performance tracking to UserButton, ProfileForm, and AuthSignUpWithTeam components to measure initialization, mount, and render times.",
            "dependencies": [
              1
            ],
            "details": "Add performance.mark() calls in component lifecycle hooks (onMounted, onUpdated) and key methods. Track time from component creation to full render completion. Measure async operations like user data fetching in useTeamAuthConfig. Add performance logging to component state changes and reactive property updates.",
            "status": "done",
            "testStrategy": "Use browser DevTools to verify component timing marks appear correctly. Test with different user states (signed in/out, with/without teams) to measure variations."
          },
          {
            "id": 3,
            "title": "Analyze Database Query Performance",
            "description": "Profile Supabase queries and database operations in auth flows to identify slow queries and potential optimization opportunities.",
            "dependencies": [
              1
            ],
            "details": "Add timing logs to database queries in server routes (`/src/runtime/server/api/`). Profile user profile fetching, team membership queries, and RLS policy execution. Use Supabase's query performance insights and add custom timing to Edge Functions. Check for N+1 patterns in team/user relationship queries.",
            "status": "done",
            "testStrategy": "Monitor query execution times in Supabase dashboard. Test with various team sizes and user configurations to identify performance bottlenecks."
          },
          {
            "id": 4,
            "title": "Profile Network Requests and API Response Times",
            "description": "Analyze network performance for auth-related API calls, Edge Functions, and data fetching operations to identify network bottlenecks.",
            "dependencies": [
              1
            ],
            "details": "Use browser DevTools Network tab to analyze auth API requests. Add timing logs to fetch operations in composables and server routes. Profile Edge Function response times for auth operations. Measure caching effectiveness for user/team data and identify unnecessary round trips in auth state management.",
            "status": "done",
            "testStrategy": "Use browser DevTools to measure network request timings. Test with different network conditions (fast 3G, slow 3G) to identify critical performance issues."
          },
          {
            "id": 5,
            "title": "Evaluate Client-Side JavaScript Performance",
            "description": "Profile JavaScript execution performance in auth components, focusing on reactive computations, component re-renders, and composable efficiency.",
            "dependencies": [
              2
            ],
            "details": "Use browser DevTools Profiler to analyze JavaScript execution in auth components. Profile useTeamAuthConfig composable performance and reactive property computations. Check component re-render frequency and identify expensive operations. Analyze memory usage patterns in auth state management.",
            "status": "done",
            "testStrategy": "Record performance profiles during typical auth flows (login, signup, profile updates). Compare execution times between different user scenarios."
          },
          {
            "id": 6,
            "title": "Compare Development vs Production Performance",
            "description": "Analyze performance differences between development and production environments to identify development-specific bottlenecks and validate optimization effectiveness.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Build production version and compare auth component performance against dev server. Measure HMR impact on auth component re-rendering. Analyze bundle size impact of auth-related code using webpack-bundle-analyzer. Profile production build performance and identify development-only overhead in auth flows.",
            "status": "done",
            "testStrategy": "Compare performance metrics between `pnpm run dev` and production build. Measure bundle sizes and loading times. Validate that optimizations work effectively in production environment."
          }
        ]
      },
      {
        "id": 42,
        "title": "Set Up Module Distribution and Release Management",
        "description": "Establish comprehensive GitHub-based distribution pipeline with versioned releases, package publishing configuration, and automated workflows to enable public consumption of the Nuxt module.",
        "details": "Configure complete distribution pipeline for the Nuxt module:\n\n1. **GitHub Release Configuration**:\n   - Set up semantic versioning with git tags\n   - Configure GitHub releases with proper changelog generation\n   - Add release notes templates and asset packaging\n\n2. **Package.json Distribution Setup**:\n   - Configure 'files' array to include only necessary distribution files\n   - Set up proper 'main', 'module', and 'types' entry points\n   - Add 'publishConfig' for GitHub Packages or npm registry\n   - Configure 'repository', 'bugs', and 'homepage' fields\n\n3. **GitHub Actions Workflow**:\n   - Create release workflow triggered by version tags\n   - Add automated testing before release\n   - Configure changelog generation from conventional commits\n   - Set up asset building and packaging\n\n4. **Test Project Migration**:\n   - Update ./test-projects/ to install from GitHub releases instead of local file references\n   - Modify package.json dependencies to use GitHub repository URLs with version tags\n   - Add validation scripts to ensure remote installation works correctly\n\n5. **Distribution Validation**:\n   - Create end-to-end test for complete installation flow\n   - Test module loading, component registration, and runtime functionality\n   - Validate TypeScript definitions are properly exported\n   - Ensure all runtime dependencies are correctly specified",
        "testStrategy": "1. Test semantic versioning workflow by creating test tags and verifying GitHub releases are generated correctly. 2. Validate package.json configuration by running 'npm pack' and inspecting the generated tarball contents. 3. Test GitHub Actions workflow in a separate branch to ensure release automation works without affecting main branch. 4. Update test project to install from a test GitHub release and verify all module functionality works identically to local development. 5. Run full test suite against the distributed version to ensure no functionality is lost in packaging. 6. Test installation in a fresh Nuxt project to validate the complete user experience. 7. Verify TypeScript definitions are properly exported by testing import statements and type checking in the test project.",
        "status": "in-progress",
        "dependencies": [
          1,
          5
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure package.json for Distribution",
            "description": "Set up package.json with proper fields for GitHub releases and NPM publishing, including entry points, file inclusions, and repository metadata.",
            "dependencies": [],
            "details": "Update package.json to include: 'files' array specifying src/runtime, dist, and package.json; set 'main' to './dist/module.mjs', 'types' to './dist/types.d.ts'; add 'repository', 'bugs', 'homepage' fields pointing to GitHub; configure 'publishConfig' for registry settings; ensure 'keywords' and 'description' are publication-ready.",
            "status": "done",
            "testStrategy": "Validate package.json structure with npm pack --dry-run to see what files would be included"
          },
          {
            "id": 2,
            "title": "Implement Semantic Versioning and Git Tag Management",
            "description": "Set up semantic versioning workflow with proper git tagging strategy and version bump automation for consistent releases.",
            "dependencies": [
              1
            ],
            "details": "Configure semantic versioning using conventional commits; set up scripts for version bumping (patch/minor/major); create git tag creation workflow; ensure version in package.json syncs with git tags; add pre-release and beta versioning support.",
            "status": "in-progress",
            "testStrategy": "Test version bump scripts locally and verify git tags are created correctly with proper semver format"
          },
          {
            "id": 3,
            "title": "Create GitHub Actions Release Workflow",
            "description": "Build automated GitHub Actions workflow that triggers on version tags to create releases with changelogs and built assets.",
            "dependencies": [
              2
            ],
            "details": "Create .github/workflows/release.yml that triggers on version tags (v*); include steps for: dependency installation, module building, testing, changelog generation from conventional commits, GitHub release creation with built assets, and optional NPM publishing.",
            "status": "pending",
            "testStrategy": "Test workflow with a pre-release tag to ensure all steps execute correctly without publishing"
          },
          {
            "id": 4,
            "title": "Set Up Release Notes and Changelog Generation",
            "description": "Configure automated changelog generation and release notes templates for consistent and informative releases.",
            "dependencies": [
              3
            ],
            "details": "Set up conventional-changelog or similar tool for automatic changelog generation; create GitHub release templates in .github/release-template.md; configure categorized changelog sections (Features, Bug Fixes, Breaking Changes); ensure commit message conventions are documented.",
            "status": "pending",
            "testStrategy": "Generate test changelog from existing commits to verify formatting and categorization"
          },
          {
            "id": 5,
            "title": "Update Test Projects for Remote Installation",
            "description": "Modify test projects to install the module from GitHub releases instead of local file references, enabling end-to-end distribution testing.",
            "dependencies": [
              1,
              3
            ],
            "details": "Update ./test-projects/*/package.json to reference GitHub repository with version tags (e.g., 'github:user/repo#v1.0.0'); create validation scripts to test installation, module loading, and runtime functionality; add CI step to test against latest release.",
            "status": "pending",
            "testStrategy": "Create test script that installs from GitHub release, runs build, and validates all module features work correctly"
          },
          {
            "id": 6,
            "title": "Create End-to-End Distribution Validation Pipeline",
            "description": "Establish comprehensive testing pipeline that validates the complete distribution flow from release creation to module consumption.",
            "dependencies": [
              4,
              5
            ],
            "details": "Create validation script that: creates a test release, installs module in fresh project, tests component loading and TypeScript definitions, validates runtime functionality, and verifies dependency resolution; add GitHub Actions job to run validation on each release.",
            "status": "pending",
            "testStrategy": "Run complete validation pipeline with a test release to ensure all distribution aspects work correctly from end to end"
          }
        ]
      },
      {
        "id": 43,
        "title": "Complete CLI Tool Functionality for Module Distribution",
        "description": "Finish implementing the CLI tool for the nuxt-supabase-team-auth module, including missing commands, testing, and proper package distribution integration.",
        "details": "Complete the CLI tool implementation for the nuxt-supabase-team-auth module:\n\n1. **Review Current CLI Implementation**:\n   - Audit existing CLI code in the codebase to identify incomplete functionality\n   - Document current command structure and identify missing commands\n   - Review CLI entry point configuration and module integration\n\n2. **Implement Missing CLI Commands**:\n   - Implement `init` command to scaffold team auth configuration in target projects\n   - Create database migration commands for setting up required tables and RLS policies\n   - Add `configure` command for setting up Supabase integration and environment variables\n   - Implement validation commands to check project setup and configuration\n\n3. **CLI Command Functionality**:\n   - `team-auth init`: Create necessary config files, add required dependencies\n   - `team-auth migrate`: Run database migrations for profiles, teams, team_members tables\n   - `team-auth configure`: Interactive setup for Supabase URL, anon key, service role\n   - `team-auth validate`: Check configuration completeness and database connectivity\n\n4. **Package Distribution Integration**:\n   - Ensure CLI binary is properly configured in package.json 'bin' field\n   - Set up proper CLI entry point with shebang and executable permissions\n   - Configure build process to include CLI in distribution bundle\n   - Test CLI installation and execution from npm/pnpm install\n\n5. **Documentation and Help System**:\n   - Implement comprehensive help text for each command\n   - Create usage examples and troubleshooting guides\n   - Add command-line argument validation and error messaging\n   - Document CLI integration in module README",
        "testStrategy": "1. **CLI Command Testing**:\n   - Test each CLI command in isolation with various argument combinations\n   - Create test projects and verify `init` command creates correct file structure\n   - Test database migration commands against clean Supabase instances\n   - Verify configuration commands properly handle environment variables\n\n2. **Package Distribution Testing**:\n   - Test CLI installation via `npm pack` and local installation\n   - Verify CLI binary is executable and accessible from PATH\n   - Test CLI functionality after module installation in test projects\n   - Validate help text and error messaging for all commands\n\n3. **Integration Testing**:\n   - Test complete workflow: init -> configure -> migrate -> validate\n   - Verify CLI-generated projects work with the module correctly\n   - Test CLI behavior with existing projects and configuration conflicts\n   - Validate CLI works across different Node.js versions and operating systems\n\n4. **Error Handling Testing**:\n   - Test CLI behavior with invalid Supabase credentials\n   - Verify graceful handling of network errors during migration\n   - Test CLI response to missing dependencies or configuration files",
        "status": "pending",
        "dependencies": [
          1,
          42
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit Existing CLI Implementation and Identify Gaps",
            "description": "Review the current CLI codebase to understand what functionality exists and what needs to be implemented or completed.",
            "dependencies": [],
            "details": "Examine src/cli directory structure, analyze existing command definitions, check package.json bin configuration, identify incomplete or missing commands (likely init, migrate, configure, validate), and document the current CLI entry point and module integration patterns.",
            "status": "pending",
            "testStrategy": "Manual testing of existing CLI commands and verification of package.json bin field configuration"
          },
          {
            "id": 2,
            "title": "Implement Core CLI Commands (init and configure)",
            "description": "Create the foundational CLI commands for project initialization and Supabase configuration setup.",
            "dependencies": [
              1
            ],
            "details": "Implement 'team-auth init' command to scaffold config files and add dependencies to target projects. Create 'team-auth configure' command for interactive Supabase setup (URL, anon key, service role). Use inquirer or similar for interactive prompts. Handle file creation, environment variable setup, and dependency management.",
            "status": "pending",
            "testStrategy": "Test commands in fresh Nuxt projects, verify config file creation, validate environment variable setup"
          },
          {
            "id": 3,
            "title": "Implement Database Migration and Validation Commands",
            "description": "Create CLI commands for database setup and project validation to complete the core functionality.",
            "dependencies": [
              2
            ],
            "details": "Implement 'team-auth migrate' command to run database migrations for profiles, teams, and team_members tables with RLS policies. Create 'team-auth validate' command to check configuration completeness, database connectivity, and proper setup. Include error handling and informative feedback for setup issues.",
            "status": "pending",
            "testStrategy": "Test migration commands against local Supabase instances, verify table creation and RLS policies, test validation against various project states"
          },
          {
            "id": 4,
            "title": "Configure CLI Distribution and Package Integration",
            "description": "Ensure the CLI tool is properly packaged and distributed with the module for end-user installation.",
            "dependencies": [
              3
            ],
            "details": "Configure package.json 'bin' field for CLI binary, set up proper CLI entry point with shebang and executable permissions, ensure build process includes CLI in distribution bundle, test CLI installation via npm/pnpm install, and verify global CLI access after module installation.",
            "status": "pending",
            "testStrategy": "Test CLI installation from published package, verify global command availability, test in different environments (local install vs global install)"
          },
          {
            "id": 5,
            "title": "Implement Help System and Documentation",
            "description": "Add comprehensive help text, command validation, and usage documentation for all CLI commands.",
            "dependencies": [
              4
            ],
            "details": "Implement help text for each command with usage examples, add command-line argument validation with clear error messages, create troubleshooting guides for common issues, document CLI integration in module README with setup workflows, and add version and help flags for the main CLI entry point.",
            "status": "pending",
            "testStrategy": "Test help text display, validate error message clarity, verify documentation accuracy against actual CLI behavior"
          }
        ]
      },
      {
        "id": 44,
        "title": "Complete and Test Social Authentication (Google OAuth) Integration",
        "description": "Complete the Google OAuth authentication implementation by creating the missing callback handler and ensuring proper integration with the team system and user profile management.",
        "status": "pending",
        "dependencies": [
          1,
          3,
          4,
          5,
          6,
          10
        ],
        "priority": "high",
        "details": "Complete the Google OAuth authentication implementation for the nuxt-supabase-team-auth module:\n\n**CURRENT STATE ANALYSIS**:\n- AuthSignIn and AuthSignUpWithTeam components already have Google OAuth buttons implemented\n- Both use Supabase's signInWithOAuth() method correctly\n- AuthSignIn redirects to `/auth/callback` for simple login flow\n- AuthSignUpWithTeam redirects to `/auth/callback?mode=signup&team_name=...` for complex signup with team creation\n- **MISSING**: No auth callback page/handler exists to process these redirects\n\n**IMPLEMENTATION REQUIREMENTS**:\n\n1. **Create Auth Callback Handler**:\n   - Implement `/auth/callback` page to handle OAuth return flows\n   - Parse URL parameters to distinguish between signin and signup modes\n   - Handle Supabase session exchange and user authentication\n   - Route users appropriately based on authentication flow type\n\n2. **Complete Google Signup Flow**:\n   - Extract team_name from callback URL parameters for signup flow\n   - Create team after Google authentication completes successfully\n   - Map Google profile data (name, email, avatar) to public.profiles table\n   - Ensure new Google users are properly added to their created teams\n   - Handle Google avatar capture and storage in user profiles\n\n3. **Verify Google Login Flow**:\n   - Ensure existing Google users can authenticate through callback handler\n   - Verify proper session management and team membership loading\n   - Confirm user routing to dashboard after successful authentication\n\n4. **Profile Integration**:\n   - Ensure Google avatar URLs are properly captured and stored\n   - Verify ProfileForm works correctly for Google-authenticated users\n   - Handle profile picture sync from Google profile data\n\n5. **Error Handling**:\n   - Handle OAuth errors and cancellations gracefully\n   - Implement proper error messages for authentication failures\n   - Manage edge cases like existing email conflicts\n\n6. **Testing and Validation**:\n   - Test complete signup flow: Google OAuth  callback  team creation\n   - Test complete login flow: Google OAuth  callback  dashboard\n   - Verify team system integration works with Google users\n   - Validate profile data consistency and avatar handling",
        "testStrategy": "1. **Callback Handler Testing**:\n   - Test `/auth/callback` page handles both signin and signup modes\n   - Verify URL parameter parsing for team_name extraction\n   - Confirm Supabase session exchange works correctly\n   - Test routing logic for different authentication flows\n\n2. **Google Signup Flow Testing**:\n   - Test complete flow: AuthSignUpWithTeam  Google OAuth  callback  team creation\n   - Verify team_name from form is preserved through OAuth flow\n   - Confirm Google profile data (name, email, avatar) is captured\n   - Test new user is properly added to created team with correct role\n\n3. **Google Login Flow Testing**:\n   - Test existing Google user login through AuthSignIn component\n   - Verify callback handler properly authenticates existing users\n   - Confirm team membership loading and dashboard access\n   - Test session persistence and user state management\n\n4. **Profile Integration Testing**:\n   - Verify Google avatar URLs are stored in public.profiles table\n   - Test ProfileForm functionality with Google-authenticated users\n   - Confirm profile picture display and update capabilities\n   - Test avatar fallback behavior if Google avatar unavailable\n\n5. **Error Scenario Testing**:\n   - Test OAuth cancellation and error handling\n   - Verify proper error messages for authentication failures\n   - Test edge cases like network connectivity issues\n   - Confirm graceful handling of existing email conflicts\n\n6. **End-to-End Integration Testing**:\n   - Test complete user journeys in playground environment\n   - Verify team operations work correctly for Google users\n   - Test impersonation system with Google-authenticated users\n   - Confirm RBAC and permission system integration\n\n7. **Cross-Browser Validation**:\n   - Test Google OAuth flow across different browsers\n   - Verify mobile authentication experience\n   - Test with various Google account types (personal, workspace)",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Auth Callback Page Handler",
            "description": "Implement the missing `/auth/callback` page to handle Google OAuth returns for both signin and signup flows.",
            "status": "in-progress",
            "dependencies": [],
            "details": "Create `/auth/callback` page in the module that handles OAuth returns from Google. Parse URL parameters to determine flow type (signin vs signup with team_name). Implement Supabase session exchange to complete authentication. Handle routing logic to direct users to appropriate destinations (dashboard for signin, team setup completion for signup). Ensure proper error handling for OAuth failures and cancellations.",
            "testStrategy": "Test callback page with both signin and signup URL patterns. Verify session exchange works and users are properly authenticated. Test error scenarios and proper error handling."
          },
          {
            "id": 2,
            "title": "Complete Google Signup with Team Creation Flow",
            "description": "Implement team creation logic in the callback handler for Google OAuth signup flows.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Extract team_name from callback URL parameters for signup mode. After successful Google authentication, create the team using the preserved team_name. Map Google profile data (name, email, avatar_url) to public.profiles table. Ensure the new Google user is added to the created team with owner role. Handle Google avatar URL capture and storage. Implement proper error handling for team creation failures.",
            "testStrategy": "Test complete signup flow from AuthSignUpWithTeam through Google OAuth to team creation. Verify team_name preservation, profile data mapping, and team membership assignment. Test Google avatar capture and storage."
          },
          {
            "id": 3,
            "title": "Verify and Test Google Login Flow",
            "description": "Ensure existing Google users can authenticate properly through the callback handler.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Test that existing Google users can successfully authenticate through AuthSignIn component. Verify the callback handler properly processes login flow without team creation. Ensure proper session management and team membership loading for existing users. Confirm user routing to dashboard after successful authentication. Test that user context and team switching work correctly for Google users.",
            "testStrategy": "Test login flow for existing Google users. Verify session state, team membership loading, and dashboard access. Test user context switching and team operations for Google-authenticated users."
          },
          {
            "id": 4,
            "title": "Validate Profile Integration and Avatar Handling",
            "description": "Ensure Google profile data and avatars are properly integrated with the profile system.",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "Verify Google avatar URLs are properly captured during authentication and stored in public.profiles.avatar_url. Test that ProfileForm component works correctly for Google-authenticated users. Ensure avatar display works in UserButton and other components. Implement proper fallback behavior when Google avatar is unavailable. Test profile picture updates and ensure consistency across the application.",
            "testStrategy": "Test avatar capture during Google authentication. Verify avatar display in UserButton and ProfileForm. Test profile updates for Google users and ensure avatar handling works correctly across all components."
          },
          {
            "id": 5,
            "title": "End-to-End Testing and Documentation",
            "description": "Conduct comprehensive testing of the complete Google OAuth integration and document the implementation.",
            "status": "pending",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Perform thorough end-to-end testing of both Google signup and login flows in the playground environment. Test error scenarios, edge cases, and cross-browser compatibility. Verify team system integration works correctly with Google users. Test impersonation and RBAC systems with Google-authenticated users. Document the callback handler implementation and any setup requirements. Create troubleshooting guide for common Google OAuth issues.",
            "testStrategy": "Comprehensive testing of complete user journeys: new Google user signup with team creation, existing Google user login, profile management, team operations, and admin features. Test across multiple browsers and devices. Document all test cases and results."
          }
        ]
      },
      {
        "id": 45,
        "title": "Complete Invitation Flow with Password Setting and Forgot Password Functionality",
        "description": "Address the critical security gap in the invitation system where invited users can access teams without ever setting up proper authentication credentials. Currently, users invited via email can access the system without passwords or proper account setup, creating a significant security vulnerability. This task implements the complete invitation flow with mandatory password setting and forgot password functionality using Supabase's built-in authentication mechanisms.",
        "status": "pending",
        "dependencies": [
          8,
          44
        ],
        "priority": "medium",
        "details": "Implement complete invitation flow with password setting and forgot password functionality to address critical security gaps:\n\n**SECURITY CONTEXT**: The current invitation system has a critical flaw where invited users can access teams without ever setting up proper authentication credentials. Users receive invitation emails but bypass the password creation process, creating unauthorized access paths.\n\n1. **Auth Confirmation Page Implementation**:\n   - Create `/auth/confirm` page to handle email confirmation links\n   - Parse URL parameters for token type (invite_confirmation vs password_reset)\n   - Handle Supabase session exchange for confirmation tokens\n   - Route users to appropriate flows based on confirmation type\n   - Implement mandatory credential setup for invited users\n\n2. **Invitation Password Setting Flow**:\n   - Create PasswordSetupForm component for new invited users\n   - Validate that user is in pending invitation state\n   - Allow password setting with confirmation field\n   - Automatically activate team membership after password is set\n   - Handle edge cases: expired invitations, already activated accounts\n   - Enforce password requirements to prevent weak credentials\n\n3. **Social Account Linking Option**:\n   - Add social OAuth buttons to password setup form\n   - Allow users to link Google account instead of setting password\n   - Maintain team invitation context during OAuth flow\n   - Handle profile data merging from OAuth providers\n   - Ensure OAuth accounts are properly validated and linked\n\n4. **Forgot Password Implementation**:\n   - Add 'Forgot Password' link to AuthSignIn component\n   - Create ForgotPasswordForm component with email input\n   - Integrate with Supabase's resetPasswordForEmail() method\n   - Create password reset confirmation page\n   - Implement ResetPasswordForm for new password entry\n\n5. **Email Template Integration**:\n   - Ensure invitation emails link to correct confirmation page\n   - Configure Supabase email templates for password reset\n   - Add proper redirect URLs for different confirmation types\n   - Implement email verification for security\n\n6. **Error Handling and Security Enforcement**:\n   - Handle expired tokens gracefully\n   - Provide clear error messages for various failure scenarios\n   - Add loading states for all async operations\n   - Implement proper form validation with Nuxt UI components\n   - Enforce authentication requirements before team access\n   - Prevent unauthorized access through incomplete invitation flows",
        "testStrategy": "1. **Security Validation Testing**:\n   - Verify invited users cannot access teams without completing credential setup\n   - Test that all invitation paths require proper authentication\n   - Confirm unauthorized access attempts are properly blocked\n   - Validate password strength requirements are enforced\n\n2. **Invitation Flow Testing**:\n   - Test complete invitation flow: send invite  receive email  click link  set password  access team\n   - Verify expired invitation tokens are handled correctly\n   - Test social account linking during invitation confirmation\n   - Confirm team membership is activated after password setting\n   - Test edge cases: multiple invitation attempts, partially completed flows\n\n3. **Password Reset Testing**:\n   - Test forgot password flow: request reset  receive email  click link  set new password  sign in\n   - Verify password reset tokens expire correctly\n   - Test edge cases: invalid tokens, already used tokens\n   - Confirm new password meets security requirements\n\n4. **Integration Testing**:\n   - Test OAuth flow integration with invitation context\n   - Verify profile data is properly merged during social linking\n   - Test navigation between different auth states\n   - Confirm proper session management throughout flows\n   - Validate team access controls work correctly\n\n5. **Security Testing**:\n   - Verify tokens cannot be reused after confirmation\n   - Test token expiration handling\n   - Confirm proper authorization checks for password setting\n   - Test CSRF protection on password reset forms\n   - Validate no bypass paths exist for credential setup\n\n6. **Email Integration Testing**:\n   - Verify correct email templates are used for different scenarios\n   - Test redirect URLs work correctly from email links\n   - Confirm email delivery for both invitation and password reset flows\n   - Test email verification prevents unauthorized access",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Auth Confirmation Page with Token Handling",
            "description": "Implement the `/auth/confirm` page that handles email confirmation links for both invitation confirmations and password reset flows.",
            "status": "done",
            "dependencies": [],
            "details": "Create `/src/runtime/pages/auth/confirm.vue` page that parses URL parameters to determine token type (invite_confirmation vs password_reset). Use Supabase's `auth.exchangeCodeForSession()` to handle confirmation tokens. Route users to appropriate next steps based on confirmation type - password setup for invitations, password reset form for forgot password flow. Include proper error handling for invalid/expired tokens.",
            "testStrategy": "Test with valid invitation tokens, password reset tokens, expired tokens, and invalid tokens. Verify routing works correctly for different token types."
          },
          {
            "id": 2,
            "title": "Build Password Setup Form for Invited Users",
            "description": "Create a PasswordSetupForm component specifically for users who have been invited to teams and need to set their initial password.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Create `/src/runtime/components/PasswordSetupForm.vue` with password and confirm password fields using UForm validation. Validate that user is in pending invitation state by checking team_members table. Use Supabase's `auth.updateUser()` to set password. After successful password setting, update team_members record to activate membership (remove pending status). Handle edge cases like expired invitations and already activated accounts.",
            "testStrategy": "Test password validation rules, successful password setting, team membership activation, and error handling for expired/invalid invitations."
          },
          {
            "id": 3,
            "title": "Add Social OAuth Integration to Password Setup",
            "description": "Extend the password setup flow to allow invited users to link their Google account instead of setting a password.",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Add Google OAuth button to PasswordSetupForm component. Implement OAuth flow that maintains team invitation context using session storage or URL parameters. Use Supabase's `auth.signInWithOAuth()` with Google provider. After OAuth success, merge profile data from Google (full_name, avatar_url) into the profiles table and activate team membership. Handle profile data conflicts and ensure proper session management.",
            "testStrategy": "Test Google OAuth flow with invitation context, profile data merging, team membership activation, and error handling for OAuth failures."
          },
          {
            "id": 4,
            "title": "Implement Forgot Password Flow",
            "description": "Add complete forgot password functionality including form, email sending, and password reset confirmation.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Add 'Forgot Password' link to AuthSignIn component. Create `/src/runtime/components/ForgotPasswordForm.vue` with email input and UForm validation. Use Supabase's `auth.resetPasswordForEmail()` method with proper redirect URL to auth/confirm page. Create `/src/runtime/components/ResetPasswordForm.vue` for entering new password after confirmation. Integrate with the auth/confirm page to handle password reset tokens and route to ResetPasswordForm.",
            "testStrategy": "Test email sending, password reset link functionality, new password setting, and error handling for invalid emails or expired reset tokens."
          },
          {
            "id": 5,
            "title": "Configure Email Templates and Error Handling",
            "description": "Ensure proper email template configuration and implement comprehensive error handling and UX improvements across all flows.",
            "status": "done",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Configure Supabase email templates for both invitation confirmations and password reset emails to use correct redirect URLs pointing to the auth/confirm page. Add comprehensive error handling for expired tokens, invalid confirmations, and network failures across all components. Implement proper loading states using local component state (not global auth loading). Add clear error messages and success feedback using UAlert components. Ensure all forms have proper validation and user feedback.",
            "testStrategy": "Test email template links, error message display, loading states, form validation, and overall user experience flow from invitation email through password setup or reset completion."
          },
          {
            "id": 6,
            "title": "Document Google OAuth manual linking for invited users",
            "description": "Update README with documentation for the manual identity linking feature that allows invited users to link Google OAuth to their existing email-based account",
            "details": "After confirming the invitation flow with Google OAuth manual linking works properly, update the project README to document:\n\n1. **Feature Description**: How invited users can choose between password setup or Google OAuth linking\n2. **Supabase Configuration**: Requirement to enable manual linking in Supabase Auth settings (Beta feature)\n3. **Technical Implementation**: Brief explanation of using linkIdentity() vs signInWithOAuth()\n4. **User Flow**: Step-by-step process from invitation email to team membership\n5. **Security Benefits**: How this prevents duplicate accounts and maintains invitation context\n6. **Prerequisites**: Manual linking must be enabled in Supabase dashboard\n\nInclude code examples and configuration screenshots if helpful for module consumers.",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 45
          },
          {
            "id": 7,
            "title": "Fix self-invitation error handling",
            "description": "Improve error handling when users try to invite themselves to their own team. Currently returns 500 error with no UI feedback.",
            "details": "- Add validation to prevent self-invitations\n- Return proper error message instead of 500\n- Display user-friendly error in UI\n- Consider adding client-side validation as well\n<info added on 2025-06-26T20:55:49.334Z>\nFixed error handling chain to properly display specific error messages from edge function. Updated server API route to extract error messages from {error: \"message\"} format responses and updated useTeamAuth composable to handle multiple error response formats (statusMessage, data.message, data.error). Users now see specific errors like \"User is already a member of this team\" instead of generic \"Failed to send invitation\" messages. Self-invitation validation was already implemented in edge function - the issue was error message propagation through the handling chain.\n</info added on 2025-06-26T20:55:49.334Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 45
          },
          {
            "id": 8,
            "title": "Test Complete Password Recovery and Invitation Flows",
            "description": "Comprehensive testing of all password recovery and invitation acceptance flows to ensure they work correctly in practice, not just in theory.",
            "details": "Test all password recovery and invitation flows end-to-end:\n\n1. **Forgot Password Flow Testing**:\n   - Test forgot password form submission from sign-in page\n   - Verify email delivery with correct reset link\n   - Test password reset confirmation page (/auth/confirm)\n   - Verify new password setting works and allows sign-in\n   - Test expired/invalid reset tokens\n\n2. **Invitation Password Setup Testing**:\n   - Send team invitation and verify email delivery\n   - Test invitation acceptance with password setup\n   - Verify team membership is activated after password creation\n   - Test password strength validation and requirements\n   - Test user can sign in with new password after setup\n\n3. **OAuth Invitation Linking Testing**:\n   - Test invitation acceptance with Google OAuth linking\n   - Verify profile data merging from Google account\n   - Confirm team membership creation via OAuth path\n   - Test avatar display updates immediately after linking\n\n4. **Edge Cases and Error Handling**:\n   - Test expired invitation tokens\n   - Test invalid confirmation codes\n   - Test self-invitation error handling (subtask 45.7)\n   - Test network failures and retry scenarios\n   - Verify proper error messages are displayed\n\n5. **Integration Testing**:\n   - Test complete invitation workflow: send  email  accept  team access\n   - Verify password recovery works for both regular and OAuth users\n   - Test that security requirements are properly enforced\n   - Confirm no bypass paths exist for credential setup\n\nThis testing is critical since password recovery is a security-sensitive feature that must work correctly in production.\"",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 45
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-06-18T17:53:26.166Z",
      "updated": "2025-06-26T21:09:29.203Z",
      "description": "Tasks for master context"
    }
  }
}